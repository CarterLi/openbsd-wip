$OpenBSD$

Index: mapi4linux/include/kopano/memory.hpp
--- mapi4linux/include/kopano/memory.hpp.orig
+++ mapi4linux/include/kopano/memory.hpp
@@ -29,57 +29,57 @@
 namespace KCHL {
 using namespace KC;
 
-template<typename _T> class memory_proxy _kc_final {
+template<typename T> class memory_proxy _kc_final {
 	public:
-	memory_proxy(_T **__p) noexcept : _m_ptr(__p) {}
-	operator _T **(void) noexcept { return _m_ptr; }
-	template<typename _U> _U **as(void) const noexcept
+	memory_proxy(T **__p) noexcept : _m_ptr(__p) {}
+	operator T **(void) noexcept { return _m_ptr; }
+	template<typename U> U **as(void) const noexcept
 	{
-		static_assert(sizeof(_U *) == sizeof(_T *), "This hack won't work");
-		return reinterpret_cast<_U **>(_m_ptr);
+		static_assert(sizeof(U *) == sizeof(T *), "This hack won't work");
+		return reinterpret_cast<U **>(_m_ptr);
 	}
 	operator void **(void) noexcept { return as<void>(); }
 
 	private:
-	_T **_m_ptr;
+	T **_m_ptr;
 };
 
-template<typename _T> class memory_proxy2 _kc_final {
+template<typename T> class memory_proxy2 _kc_final {
 	public:
-	memory_proxy2(_T **__p) noexcept : _m_ptr(__p) {}
-	memory_proxy<_T> operator&(void)
+	memory_proxy2(T **__p) noexcept : _m_ptr(__p) {}
+	memory_proxy<T> operator&(void)
 	{
-		return memory_proxy<_T>(_m_ptr);
+		return memory_proxy<T>(_m_ptr);
 	}
 
 	private:
-	_T **_m_ptr;
+	T **_m_ptr;
 };
 
-template<typename _T> class object_proxy _kc_final {
+template<typename T> class object_proxy _kc_final {
 	public:
-	object_proxy(_T **__p) noexcept : _m_ptr(__p) {}
-	operator _T **(void) noexcept { return _m_ptr; }
-	template<typename _U> _U **as(void) const noexcept
+	object_proxy(T **__p) noexcept : _m_ptr(__p) {}
+	operator T **(void) noexcept { return _m_ptr; }
+	template<typename U> U **as(void) const noexcept
 	{
-		static_assert(sizeof(_U *) == sizeof(_T *), "This hack won't work");
-		return reinterpret_cast<_U **>(_m_ptr);
+		static_assert(sizeof(U *) == sizeof(T *), "This hack won't work");
+		return reinterpret_cast<U **>(_m_ptr);
 	}
 	operator void **(void) noexcept { return as<void>(); }
 	operator IUnknown **(void) noexcept { return as<IUnknown>(); }
 
 	private:
-	_T **_m_ptr;
+	T **_m_ptr;
 };
 
 template<> class object_proxy<IUnknown> _kc_final {
 	public:
 	object_proxy(IUnknown **__p) noexcept : _m_ptr(__p) {}
 	operator IUnknown **(void) noexcept { return _m_ptr; }
-	template<typename _U> _U **as(void) const noexcept
+	template<typename U> U **as(void) const noexcept
 	{
-		static_assert(sizeof(_U *) == sizeof(IUnknown *), "This hack won't work");
-		return reinterpret_cast<_U **>(_m_ptr);
+		static_assert(sizeof(U *) == sizeof(IUnknown *), "This hack won't work");
+		return reinterpret_cast<U **>(_m_ptr);
 	}
 	operator void **(void) noexcept { return as<void>(); }
 
@@ -87,16 +87,16 @@ template<> class object_proxy<IUnknown> _kc_final {
 	IUnknown **_m_ptr;
 };
 
-template<typename _T> class object_proxy2 _kc_final {
+template<typename T> class object_proxy2 _kc_final {
 	public:
-	object_proxy2(_T **__p) noexcept : _m_ptr(__p) {}
-	object_proxy<_T> operator&(void)
+	object_proxy2(T **__p) noexcept : _m_ptr(__p) {}
+	object_proxy<T> operator&(void)
 	{
-		return object_proxy<_T>(_m_ptr);
+		return object_proxy<T>(_m_ptr);
 	}
 
 	private:
-	_T **_m_ptr;
+	T **_m_ptr;
 };
 
 class default_delete {
@@ -117,13 +117,13 @@ class default_delete {
  *  - methods "is_null", "free" and "as" are gone
  *  - operator void** and operator! is gone
  */
-template<typename _T, typename _Deleter = default_delete> class memory_ptr {
+template<typename T, typename _Deleter = default_delete> class memory_ptr {
 	public:
-	typedef _T value_type;
-	typedef _T *pointer;
+	typedef T value_type;
+	typedef T *pointer;
 	constexpr memory_ptr(void) noexcept {}
 	constexpr memory_ptr(std::nullptr_t) noexcept {}
-	explicit memory_ptr(_T *__p) noexcept : _m_ptr(__p) {}
+	explicit memory_ptr(T *__p) noexcept : _m_ptr(__p) {}
 	~memory_ptr(void)
 	{
 		if (_m_ptr != nullptr)
@@ -138,19 +138,19 @@ template<typename _T, typename _Deleter = default_dele
 	memory_ptr(const memory_ptr &) = delete;
 	memory_ptr(memory_ptr &&__o) : _m_ptr(__o.release()) {}
 	/* Observers */
-	_T &operator*(void) const { return *_m_ptr; }
-	_T *operator->(void) const noexcept { return _m_ptr; }
-	_T *get(void) const noexcept { return _m_ptr; }
-	operator _T *(void) const noexcept { return _m_ptr; }
-	_T *operator+(size_t __n) const noexcept { return _m_ptr + __n; }
+	T &operator*(void) const { return *_m_ptr; }
+	T *operator->(void) const noexcept { return _m_ptr; }
+	T *get(void) const noexcept { return _m_ptr; }
+	operator T *(void) const noexcept { return _m_ptr; }
+	T *operator+(size_t __n) const noexcept { return _m_ptr + __n; }
 	/* Modifiers */
-	_T *release(void) noexcept
+	T *release(void) noexcept
 	{
-		_T *__p = get();
+		T *__p = get();
 		_m_ptr = pointer();
 		return __p;
 	}
-	void reset(_T *__p = pointer()) noexcept
+	void reset(T *__p = pointer()) noexcept
 	{
 		std::swap(_m_ptr, __p);
 		if (__p != pointer())
@@ -160,14 +160,14 @@ template<typename _T, typename _Deleter = default_dele
 	{
 		std::swap(_m_ptr, __o._m_ptr);
 	}
-	memory_proxy2<_T> operator~(void)
+	memory_proxy2<T> operator~(void)
 	{
 		reset();
-		return memory_proxy2<_T>(&_m_ptr);
+		return memory_proxy2<T>(&_m_ptr);
 	}
-	memory_proxy2<_T> operator+(void)
+	memory_proxy2<T> operator+(void)
 	{
-		return memory_proxy2<_T>(&_m_ptr);
+		return memory_proxy2<T>(&_m_ptr);
 	}
 	memory_ptr &operator=(const memory_ptr &) = delete;
 	memory_ptr &operator=(memory_ptr &&__o) noexcept
@@ -184,20 +184,20 @@ template<typename _T, typename _Deleter = default_dele
 	private:
 	void operator&(void) const noexcept {} /* flag everyone */
 
-	_T *_m_ptr = nullptr;
+	T *_m_ptr = nullptr;
 };
 
 /**
  * Works a bit like shared_ptr, except that the refcounting is in the
- * underlying object (_T) rather than this class.
+ * underlying object (T) rather than this class.
  */
-template<typename _T> class object_ptr {
+template<typename T> class object_ptr {
 	public:
-	typedef _T value_type;
-	typedef _T *pointer;
+	typedef T value_type;
+	typedef T *pointer;
 	constexpr object_ptr(void) noexcept {}
 	constexpr object_ptr(std::nullptr_t) noexcept {}
-	explicit object_ptr(_T *__p, bool __addref = true) : _m_ptr(__p)
+	explicit object_ptr(T *__p, bool __addref = true) : _m_ptr(__p)
 	{
 		if (__addref && _m_ptr != pointer())
 			_m_ptr->AddRef();
@@ -221,21 +221,21 @@ template<typename _T> class object_ptr {
 			__old->Release();
 	}
 	/* Observers */
-	_T &operator*(void) const { return *_m_ptr; }
-	_T *operator->(void) const noexcept { return _m_ptr; }
-	_T *get(void) const noexcept { return _m_ptr; }
-	operator _T *(void) const noexcept { return _m_ptr; }
-	template<typename _U> HRESULT QueryInterface(_U &);
-	template<typename _P> _P as();
+	T &operator*(void) const { return *_m_ptr; }
+	T *operator->(void) const noexcept { return _m_ptr; }
+	T *get(void) const noexcept { return _m_ptr; }
+	operator T *(void) const noexcept { return _m_ptr; }
+	template<typename U> HRESULT QueryInterface(U &);
+	template<typename P> P as();
 
 	/* Modifiers */
-	_T *release(void) noexcept
+	T *release(void) noexcept
 	{
-		_T *__p = get();
+		T *__p = get();
 		_m_ptr = pointer();
 		return __p;
 	}
-	void reset(_T *__p = pointer(), bool __addref = true) noexcept
+	void reset(T *__p = pointer(), bool __addref = true) noexcept
 	{
 		if (__addref && __p != pointer())
 			__p->AddRef();
@@ -247,14 +247,14 @@ template<typename _T> class object_ptr {
 	{
 		std::swap(_m_ptr, __o._m_ptr);
 	}
-	object_proxy2<_T> operator~(void)
+	object_proxy2<T> operator~(void)
 	{
 		reset();
-		return object_proxy2<_T>(&_m_ptr);
+		return object_proxy2<T>(&_m_ptr);
 	}
-	object_proxy2<_T> operator+(void)
+	object_proxy2<T> operator+(void)
 	{
-		return object_proxy2<_T>(&_m_ptr);
+		return object_proxy2<T>(&_m_ptr);
 	}
 	object_ptr &operator=(const object_ptr &__o) noexcept
 	{
@@ -274,7 +274,7 @@ template<typename _T> class object_ptr {
 	void operator=(std::nullptr_t) noexcept {}
 	void operator&(void) const noexcept {} /* flag everyone */
 
-	_T *_m_ptr = nullptr;
+	T *_m_ptr = nullptr;
 };
 
 class cstdlib_deleter {
@@ -293,14 +293,14 @@ typedef memory_ptr<ADRLIST, rowset_delete> adrlist_ptr
 typedef memory_ptr<SRowSet, rowset_delete> rowset_ptr;
 typedef memory_ptr<ROWLIST, rowset_delete> rowlist_ptr;
 
-template<typename _T> inline void
-swap(memory_ptr<_T> &__x, memory_ptr<_T> &__y) noexcept
+template<typename T> inline void
+swap(memory_ptr<T> &__x, memory_ptr<T> &__y) noexcept
 {
 	__x.swap(__y);
 }
 
-template<typename _T> inline void
-swap(object_ptr<_T> &__x, object_ptr<_T> &__y) noexcept
+template<typename T> inline void
+swap(object_ptr<T> &__x, object_ptr<T> &__y) noexcept
 {
 	__x.swap(__y);
 }
@@ -309,22 +309,22 @@ swap(object_ptr<_T> &__x, object_ptr<_T> &__y) noexcep
 
 namespace KC {
 
-template<typename _U> static inline constexpr const IID &
-iid_of(const KCHL::object_ptr<_U> &)
+template<typename U> static inline constexpr const IID &
+iid_of(const KCHL::object_ptr<U> &)
 {
-	return iid_of(static_cast<const _U *>(nullptr));
+	return iid_of(static_cast<const U *>(nullptr));
 }
 
 } /* namespace KC */
 
 namespace KCHL {
 
-template<typename _T > template<typename _U>
-HRESULT object_ptr<_T>::QueryInterface(_U &result)
+template<typename T > template<typename U>
+HRESULT object_ptr<T>::QueryInterface(U &result)
 {
 	if (_m_ptr == nullptr)
 		return MAPI_E_NOT_INITIALIZED;
-	typename _U::pointer newobj = nullptr;
+	typename U::pointer newobj = nullptr;
 	HRESULT hr = _m_ptr->QueryInterface(iid_of(result), reinterpret_cast<void **>(&newobj));
 	if (hr == hrSuccess)
 		result.reset(newobj, false);
@@ -356,9 +356,9 @@ HRESULT object_ptr<_T>::QueryInterface(_U &result)
 	return hr;
 }
 
-template<typename _T> template<typename _P> _P object_ptr<_T>::as(void)
+template<typename T> template<typename P> P object_ptr<T>::as(void)
 {
-	_P tmp = nullptr;
+	P tmp = nullptr;
 	QueryInterface(tmp);
 	return tmp;
 }
