- Feature attributes are only allowed on the nightly release channel.
  See rustc --explain E0554

- Suppress use of unstable library feature 'test': `bench` is a part of custom
  test frameworks which are unstable.
  See rustc --explain E0658

- Fix tests for character_by_alias function

Index: modcargo-crates/unicode_names2-0.6.0/src/lib.rs
--- modcargo-crates/unicode_names2-0.6.0/src/lib.rs.orig
+++ modcargo-crates/unicode_names2-0.6.0/src/lib.rs
@@ -34,8 +34,6 @@
 //!   string) is required, unless you use a raw string.
 //!
 //! ```rust
-//! #![feature(proc_macro_hygiene)]
-//!
 //! #[macro_use]
 //! extern crate unicode_names2_macros;
 //!
@@ -62,10 +60,8 @@
 //! unicode_names2_macros = "0.2"
 //! ```
 
-#![cfg_attr(feature = "no_std", feature(no_std, core))]
 #![cfg_attr(feature = "no_std", no_std)]
 
-#![cfg_attr(test, feature(test))]
 #![deny(missing_docs, unsafe_code)]
 
 #[cfg(feature = "no_std")]
@@ -78,7 +74,6 @@ extern crate std;
 
 extern crate phf;
 
-#[cfg(test)] extern crate test;
 #[cfg(test)] extern crate rand;
 
 #[cfg(feature = "no_std")]
@@ -304,14 +299,6 @@ fn split(hash: u64) -> (u32, u32, u32) {
 }
 
 /// Get alias value from alias name, returns `None` if the alias is not found.
-///
-/// # Examples
-///
-/// ```
-///
-/// assert_eq!(character_by_alias("NEW LINE"), Some('\n'));
-/// assert_eq!(character_by_alias("BACKSPACE"), Some('\u{8}'));
-/// assert_eq!(character_by_alias("NOT AN ALIAS"), None);
 fn character_by_alias(name: &[u8]) -> Option<char> {
     ALIASES.get(name).copied()
 }
@@ -469,10 +456,8 @@ static ASCII_UPPER_MAP: [u8; 256] = [
 mod tests {
     use std::prelude::v1::*;
     use std::char;
-    use rand::{seq, XorShiftRng, SeedableRng};
 
-    use test::{self, Bencher};
-    use super::{generated, name, character, is_cjk_unified_ideograph, jamo, Name};
+    use super::{generated, name, character, is_cjk_unified_ideograph, jamo};
 
     static DATA: &'static str = include_str!(concat!(env!("CARGO_MANIFEST_DIR"),
                                                      "/data/UnicodeData.txt"));
@@ -620,82 +605,11 @@ mod tests {
         assert_eq!(character("CJK UNIFIED IDEOGRAPH-2A6FF"), None);
     }
 
-
-    #[bench]
-    fn name_basic(b: &mut Bencher) {
-        b.iter(|| {
-            for s in name('รถ').unwrap() {
-                test::black_box(s);
-            }
-        })
-    }
-
-    #[bench]
-    fn character_basic(b: &mut Bencher) {
-        b.iter(|| character("LATIN SMALL LETTER O WITH DIAERESIS"));
-    }
-
-    #[bench]
-    fn name_10000_invalid(b: &mut Bencher) {
-        // be consistent across runs, but avoid sequential/caching.
-        let mut rng: XorShiftRng = SeedableRng::from_seed([0xFF, 0x00, 0xFF, 0x00, 0xF0, 0xF0, 0xF0, 0xF0,
-                                                           0x00, 0xFF, 0x00, 0xFF, 0x0F, 0x0F, 0x0F, 0x0F]);
-        let chars = seq::sample_iter(&mut rng,
-                                     (0u32..0x10FFFF)
-                                     .filter_map(|x| {
-                                         match char::from_u32(x) {
-                                             Some(c) if name(c).is_none() => Some(c),
-                                             _ => None
-                                         }
-                                     }),
-                                     10000)
-            .unwrap();
-
-        b.iter(|| {
-            for &c in chars.iter() {
-                assert!(name(c).is_none());
-            }
-        })
-    }
-
-    #[bench]
-    fn name_all_valid(b: &mut Bencher) {
-        let chars = (0u32..0x10FFFF)
-            .filter_map(|x| {
-                match char::from_u32(x) {
-                    Some(c) if name(c).is_some() => Some(c),
-                    _ => None
-                }
-            }).collect::<Vec<char>>();
-
-        b.iter(|| {
-            for c in chars.iter() {
-                for s in name(*c).unwrap() {
-                    test::black_box(s);
-                }
-            }
-        });
-    }
-
-    #[bench]
-    fn character_10000(b: &mut Bencher) {
-        // be consistent across runs, but avoid sequential/caching.
-        let mut rng: XorShiftRng = SeedableRng::from_seed([0xFF, 0x00, 0xFF, 0x00, 0xF0, 0xF0, 0xF0, 0xF0,
-                                                           0x00, 0xFF, 0x00, 0xFF, 0x0F, 0x0F, 0x0F, 0x0F]);
-
-        let names = seq::sample_iter(&mut rng,
-                                     (0u32..0x10FFFFF).filter_map(|x| char::from_u32(x).and_then(name)),
-                                     10000)
-            .unwrap()
-            .iter()
-            .map(|n: &Name| n.to_string())
-            .collect::<Vec<_>>();
-
-        b.iter(|| {
-            for n in names.iter() {
-                test::black_box(character(&n));
-            }
-        })
+    #[test]
+    fn character_by_alias() {
+        assert_eq!(super::character_by_alias(b"NEW LINE"), Some('\n'));
+        assert_eq!(super::character_by_alias(b"BACKSPACE"), Some('\u{8}'));
+        assert_eq!(super::character_by_alias(b"NOT AN ALIAS"), None);
     }
 }
 
