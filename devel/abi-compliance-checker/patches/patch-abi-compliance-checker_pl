$OpenBSD$
--- abi-compliance-checker.pl.orig	Fri Nov 23 15:59:42 2012
+++ abi-compliance-checker.pl	Fri Nov 23 19:35:17 2012
@@ -54,6 +54,7 @@ Getopt::Long::Configure ("posix_default", "no_ignore_c
 use File::Path qw(mkpath rmtree);
 use File::Temp qw(tempdir);
 use File::Copy qw(copy move);
+use IPC::Open2;
 use Cwd qw(abs_path cwd);
 use Data::Dumper;
 use Config;
@@ -7376,12 +7377,12 @@ sub checkCTags($)
     if(not $Path) {
         return;
     }
-    my $CTags = get_CmdPath("ctags");
+    my $CTags = get_CmdPath("ectags");
     if(not $CTags) {
         return;
     }
     my $Out = $TMP_DIR."/ctags.txt";
-    system("$CTags --c-kinds=pxn -f \"$Out\" \"$Path\"");
+    system { $CTags } ($CTags, "--c-kinds=pxn", "-f", $Out, $Path);
     if($Debug) {
         copy($Out, $DEBUG_PATH{$Version}."/ctags.txt");
     }
@@ -7743,12 +7744,13 @@ sub getDump()
             and ($Errors=~/\Q-std=c++0x\E/
             or $Errors=~/is not a class or namespace/))
             { # c++0x: enum class
-                $Cpp0xMode{$Version}=-1;
-                printMsg("INFO", "Enabling c++0x mode");
-                resetLogging($Version);
-                $TMP_DIR = tempdir(CLEANUP=>1);
-                $CompilerOptions{$Version} .= " -std=c++0x";
-                return getDump();
+                printMsg("ERROR", "Probably c++0x construction detected");
+#                $Cpp0xMode{$Version}=-1;
+#                printMsg("INFO", "Enabling c++0x mode");
+#                resetLogging($Version);
+#                $TMP_DIR = tempdir(CLEANUP=>1);
+#                $CompilerOptions{$Version} .= " -std=c++0x";
+#                return getDump();
             }
             elsif($MinGWMode{$Version}==1)
             { # disable MinGW mode and try again
@@ -7850,11 +7852,11 @@ sub callPreprocessor($$$)
     return $Out;
 }
 
-sub cmd_find($$$$)
+sub cmd_find($$$$;$)
 { # native "find" is much faster than File::Find (~6x)
   # also the File::Find doesn't support --maxdepth N option
   # so using the cross-platform wrapper for the native one
-    my ($Path, $Type, $Name, $MaxDepth) = @_;
+    my ($Path, $Type, $Name, $MaxDepth, $UseRegex) = @_;
     return () if(not $Path or not -e $Path);
     if($OSgroup eq "windows")
     {
@@ -7915,27 +7917,36 @@ sub cmd_find($$$$)
         { # for directories that are symlinks
             $Path.="/";
         }
-        my $Cmd = $FindCmd." \"$Path\"";
+        my @Cmd = ($FindCmd, "-f", $Path, '--');
         if($MaxDepth) {
-            $Cmd .= " -maxdepth $MaxDepth";
+            push(@Cmd, "-maxdepth", $MaxDepth);
         }
         if($Type) {
-            $Cmd .= " -type $Type";
+            push(@Cmd, "-type", $Type);
         }
-        if($Name)
-        { # file name
-            if($Name=~/\]/) {
-                $Cmd .= " -regex \"$Name\"";
-            }
-            else {
-                $Cmd .= " -name \"$Name\"";
-            }
+        if($Name and not $UseRegex)
+        { # file name glob
+            push(@Cmd, "-name", $Name);
         }
-        my $Res = `$Cmd 2>\"$TMP_DIR/null\"`;
-        if($?) {
-            printMsg("ERROR", "problem with \'find\' utility ($?): $!");
+        my ($In, $Out, $Pid);
+        eval { $Pid = open2($Out, $In, @Cmd); };
+        if($@) {
+            printMsg("ERROR", "problem with \'find\' utility: $@");
+            return ();
         }
-        return split(/\n/, $Res);
+        my @Files;
+        if($Name and $UseRegex)
+        { # file name regex
+            while(<$Out>) {
+                next unless /^${Name}$/;
+                push(@Files, $_);
+            }
+        } else {
+            @Files = <$Out>;
+        }
+        waitpid($Pid, 0);
+        chomp @Files;
+        return @Files;
     }
 }
 
@@ -13719,6 +13730,13 @@ sub esc($)
     return $Str;
 }
 
+sub globesc($)
+{
+    my $Str = $_[0];
+    $Str=~s/([\[\]*?])/\\$1/g;
+    return $Str;
+}
+
 sub readLineNum($$)
 {
     my ($Path, $Num) = @_;
@@ -17234,7 +17252,7 @@ sub getSOPaths_Dest($$)
         if($SystemPaths{"lib"}{$Dest})
         { # you have specified /usr/lib as the search directory (<libs>) in the XML descriptor
           # and the real name of the library by -l option (bz2, stdc++, Xaw, ...)
-            foreach my $Path (cmd_find($Dest,"","*".esc($TargetLibraryName)."*\.$LIB_EXT*",2))
+            foreach my $Path (cmd_find($Dest,"","*".globesc($TargetLibraryName)."*.$LIB_EXT*",2))
             { # all files and symlinks that match the name of a library
                 if(get_filename($Path)=~/\A(|lib)\Q$TargetLibraryName\E[\d\-]*\.$LIB_EXT[\d\.]*\Z/i)
                 {
@@ -17811,7 +17829,7 @@ sub find_libs($$$)
 {
     my ($Path, $Type, $MaxDepth) = @_;
     # FIXME: correct the search pattern
-    return cmd_find($Path, $Type, ".*\\.$LIB_EXT\[0-9.]*", $MaxDepth);
+    return cmd_find($Path, $Type, ".*\\.$LIB_EXT\[0-9.]*", $MaxDepth, 1);
 }
 
 sub createDescriptor($$)
@@ -18148,7 +18166,7 @@ sub detect_default_paths($)
             foreach my $Path (sort {$b=~/\/usr\/bin/ cmp $a=~/\/usr\/bin/}
             keys(%{$SystemPaths{"bin"}}))
             {
-                if(my @GCCs = cmd_find($Path, "", ".*/gcc-[0-9.]*", 1))
+                if(my @GCCs = cmd_find($Path, "", ".*/gcc-[0-9.]*", 1, 1))
                 { # select the latest version
                     @GCCs = sort {$b cmp $a} @GCCs;
                     if(check_gcc($GCCs[0], "3"))
