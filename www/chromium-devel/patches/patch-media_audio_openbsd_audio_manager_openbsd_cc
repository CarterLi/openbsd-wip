$OpenBSD$
--- media/audio/openbsd/audio_manager_openbsd.cc.orig	Wed Nov  9 11:40:00 2011
+++ media/audio/openbsd/audio_manager_openbsd.cc	Wed Nov  9 21:26:24 2011
@@ -4,21 +4,74 @@
 
 #include "media/audio/openbsd/audio_manager_openbsd.h"
 
+#include "base/command_line.h"
+#include "media/audio/audio_output_dispatcher.h"
+#include "media/audio/fake_audio_input_stream.h"
+#include "media/audio/fake_audio_output_stream.h"
+#if defined(USE_PULSEAUDIO)
+#include "media/audio/pulse/pulse_output.h"
+#endif
+#include "media/base/limits.h"
+#include "media/base/media_switches.h"
+
+#include <fcntl.h>
+
+// Maximum number of output streams that can be open simultaneously.
+static const size_t kMaxOutputStreams = 50;
+
 // Implementation of AudioManager.
+static bool HasAudioHardware() {
+  int fd;
+  const char *file;
+
+  if ((file = getenv("AUDIOCTLDEVICE")) == 0 || *file == '\0')
+    file = "/dev/audioctl";
+
+  if ((fd = open(file, O_RDONLY)) < 0)
+    return false;
+
+  close(fd);
+  return true;
+}
+
 bool AudioManagerOpenBSD::HasAudioOutputDevices() {
-  NOTIMPLEMENTED();
-  return false;
+  return HasAudioHardware();
 }
 
 bool AudioManagerOpenBSD::HasAudioInputDevices() {
-  NOTIMPLEMENTED();
-  return false;
+  return HasAudioHardware();
 }
 
 AudioOutputStream* AudioManagerOpenBSD::MakeAudioOutputStream(
     const AudioParameters& params) {
-  NOTIMPLEMENTED();
-  return NULL;
+  // Early return for testing hook.  Do this before checking for
+  // |initialized_|.
+  if (params.format == AudioParameters::AUDIO_MOCK) {
+    return FakeAudioOutputStream::MakeFakeStream(params);
+  }
+
+  if (!initialized()) {
+    return NULL;
+  }
+
+  // Don't allow opening more than |kMaxOutputStreams| streams.
+  if (active_streams_.size() >= kMaxOutputStreams) {
+    return NULL;
+  }
+
+  AudioOutputStream* stream;
+#if defined(USE_PULSEAUDIO)
+  if (CommandLine::ForCurrentProcess()->HasSwitch(switches::kUsePulseAudio)) {
+    stream = new PulseAudioOutputStream(params, this, GetMessageLoop());
+    active_streams_.insert(stream);
+    return stream;
+  } else {
+#endif
+    NOTIMPLEMENTED();
+    return NULL;
+#if defined(USE_PULSEAUDIO)
+  }
+#endif
 }
 
 AudioInputStream* AudioManagerOpenBSD::MakeAudioInputStream(
@@ -39,6 +92,13 @@ void AudioManagerOpenBSD::MuteAll() {
 
 void AudioManagerOpenBSD::UnMuteAll() {
   NOTIMPLEMENTED();
+}
+
+void AudioManagerOpenBSD::ReleaseOutputStream(AudioOutputStream* stream) {
+  if (stream) {
+    active_streams_.erase(stream);
+    delete stream;
+  }
 }
 
 bool AudioManagerOpenBSD::IsRecordingInProgress() {
