$OpenBSD$
--- libs/iovm/source/IoNumber.c.orig	Tue Nov 29 20:53:59 2011
+++ libs/iovm/source/IoNumber.c	Sat Dec 17 19:50:47 2011
@@ -22,6 +22,8 @@ A container for a double (a 64bit floating point numbe
 #include <math.h>
 #include <ctype.h>
 #include <assert.h>
+#include <string.h>
+#include <stdio.h>
 
 #include <setjmp.h>
 #if defined(_BSD_PPC_SETJMP_H_)
@@ -57,6 +59,111 @@ double log2(double n)
 
 static const char *protoId = "Number";
 
+
+/*
+ * http://stackoverflow.com/a/7097567/164254
+ * License: Creative Commons
+ */
+
+static double PRECISION[] = {
+		0.1,
+		0.01,
+		0.001,
+		0.0001,
+		0.00001,
+		0.000001,
+		0.0000001,
+		0.00000001,
+		0.000000001,
+		0.0000000001,
+		0.00000000001,
+		0.000000000001,
+		0.0000000000001,
+		0.00000000000001,
+		0.000000000000001,
+		0.0000000000000001, /* 16 */
+};
+
+/* Double to ASCII */
+static char * dtoa(char *s, double n, unsigned places) {
+	if (--places > 15) places = 15;
+	// crude attempt to bias number so that the string result is rounded up
+	double bias = PRECISION[places] / 2;
+	if (abs(n) > bias)
+		if (n < 0) n -= bias;
+		else       n += bias;
+	// handle special cases
+	if (isnan(n)) {
+		strcpy(s, "nan");
+	} else if (isinf(n)) {
+		strcpy(s, "inf");
+	} else if (n == 0.0) {
+		strcpy(s, "0");
+	} else {
+		int digit, m, m1;
+		char *c = s;
+		int neg = (n < 0);
+		if (neg)
+			n = -n;
+		// calculate magnitude
+		m = log10(n);
+		int useExp = (m >= 14 || (neg && m >= 9) || m <= -9);
+		if (neg)
+			*(c++) = '-';
+		// set up for scientific notation
+		if (useExp) {
+			if (m < 0)
+			   m -= 1.0;
+			n = n / pow(10.0, m);
+			m1 = m;
+			m = 0;
+		}
+		if (m < 1.0) {
+			m = 0;
+		}
+		// convert the number
+		while (n > PRECISION[places] || m >= 0) {
+			double weight = pow(10.0, m);
+			if (weight > 0 && !isinf(weight)) {
+				digit = floor(n / weight);
+				n -= (digit * weight);
+				*(c++) = '0' + digit;
+			}
+			if (m == 0 && n - bias > 0)
+				*(c++) = '.';
+			m--;
+		}
+		if (useExp) {
+			// convert the exponent
+			int i, j;
+			*(c++) = 'e';
+			if (m1 > 0) {
+				*(c++) = '+';
+			} else {
+				*(c++) = '-';
+				m1 = -m1;
+			}
+			m = 0;
+			while (m1 > 0) {
+				*(c++) = '0' + m1 % 10;
+				m1 /= 10;
+				m++;
+			}
+			c -= m;
+			for (i = 0, j = m-1; i<j; i++, j--) {
+				// swap without temporary
+				c[i] ^= c[j];
+				c[j] ^= c[i];
+				c[i] ^= c[j];
+			}
+			c += m;
+		}
+		*(c) = '\0';
+	}
+	return s;
+}
+
+
 IoNumber *IoNumber_numberForDouble_canUse_(IoNumber *self, double n, IoNumber *other)
 {
 	if (DATA(self)  == n) return self;
@@ -292,31 +399,7 @@ int IoNumber_compare(IoNumber *self, IoNumber *v)
 
 void IoNumber_Double_intoCString_(double n, char *s, size_t maxSize)
 {
-	if (n == (int)n)
-	{
-		snprintf(s, maxSize, "%d", (int)n);
-	}
-	else if (n > INT_MAX)
-	{
-		snprintf(s, maxSize, "%e", n);
-	}
-	else
-	{
-		long l;
-
-		snprintf(s, maxSize, "%.16f", n);
-
-		// remove the trailing zeros ex: 10.00 -> 10
-
-		l = (long)strlen(s) - 1;
-
-		while (l > 0)
-		{
-			if (s[l] == '0') { s[l] = 0; l--; continue; }
-			if (s[l] == '.') { s[l] = 0; l--; break; }
-			break;
-		}
-	}
+	dtoa(s, n, 15);
 }
 
 void IoNumber_print(IoNumber *self)
@@ -576,7 +659,8 @@ would return:
 		length = 1024;
 		s = io_calloc(1, length);
 
-		snprintf(s, length, "%*.*f", whole, part, DATA(self));
+		/* bug: this hack dont' support whole */
+		dtoa(s, DATA(self), part);
 
 		n = IOSEQ((unsigned char *)s, (size_t)strlen(s));
 
