$OpenBSD$
--- src/ProcessInfo.cpp.orig	Wed Jun 20 01:54:21 2012
+++ src/ProcessInfo.cpp	Fri Aug 10 13:24:29 2012
@@ -57,12 +57,14 @@
 #include <kde_file.h>
 #endif
 
-#if defined(Q_OS_FREEBSD)
+#if defined(Q_OS_FREEBSD) || defined(Q_OS_OPENBSD)
 #include <sys/sysctl.h>
 #include <sys/types.h>
 #include <sys/user.h>
 #include <sys/syslimits.h>
-#include <libutil.h>
+#   if defined(Q_OS_FREEBSD)
+#   include <libutil.h>
+#   endif
 #endif
 
 using namespace Konsole;
@@ -607,60 +609,117 @@ class LinuxProcessInfo : public UnixProcessInfo (priva
     }
 };
 
-#if defined(Q_OS_FREEBSD)
-class FreeBSDProcessInfo : public UnixProcessInfo
+#if defined(Q_OS_FREEBSD) || defined(Q_OS_OPENBSD)
+class BSDProcessInfo : public UnixProcessInfo
 {
 public:
-    FreeBSDProcessInfo(int aPid, bool readEnvironment) :
+    BSDProcessInfo(int aPid, bool readEnvironment) :
         UnixProcessInfo(aPid, readEnvironment) {
     }
 
 private:
     virtual bool readProcInfo(int aPid) {
-        int managementInfoBase[4];
-        size_t mibLength;
+        int managementInfoBase[6];
+        size_t mibLength, mibCnt;
         struct kinfo_proc* kInfoProc;
 
         managementInfoBase[0] = CTL_KERN;
         managementInfoBase[1] = KERN_PROC;
         managementInfoBase[2] = KERN_PROC_PID;
         managementInfoBase[3] = aPid;
+#if defined(Q_OS_OPENBSD)
+        managementInfoBase[4] = sizeof(struct kinfo_proc);
+        managementInfoBase[5] = 1;
+#endif
 
-        if (sysctl(managementInfoBase, 4, NULL, &mibLength, NULL, 0) == -1)
+        if (sysctl(managementInfoBase, mibCnt, NULL, &mibLength, NULL, 0) == -1)
             return false;
 
         kInfoProc = new struct kinfo_proc [mibLength];
 
-        if (sysctl(managementInfoBase, 4, kInfoProc, &mibLength, NULL, 0) == -1) {
+        if (sysctl(managementInfoBase, mibCnt, kInfoProc, &mibLength, NULL, 0) == -1) {
             delete [] kInfoProc;
             return false;
         }
 
-#if defined(__DragonFly__)
+#if defined(Q_OS_OPENBSD))
+        setName(kInfoProc->p_comm);
+        setPid(kInfoProc->p_pid);
+        setParentPid(kInfoProc->p_ppid);
+        setForegroundPid(kInfoProc->p_tpgid);
+        setUserId(kInfoProc->p_uid);
+        setUserName(kInfoProc->p_login);
+#elif defined(__DragonFly__)
         setName(kInfoProc->kp_comm);
         setPid(kInfoProc->kp_pid);
         setParentPid(kInfoProc->kp_ppid);
         setForegroundPid(kInfoProc->kp_pgid);
         setUserId(kInfoProc->kp_uid);
+        readUserName();
 #else
         setName(kInfoProc->ki_comm);
         setPid(kInfoProc->ki_pid);
         setParentPid(kInfoProc->ki_ppid);
         setForegroundPid(kInfoProc->ki_pgid);
         setUserId(kInfoProc->ki_uid);
+        readUserName();
 #endif
 
-        readUserName();
-
         delete [] kInfoProc;
         return true;
     }
 
+#if defined(Q_OS_OPENBSD)
+    char** readProcArgs(int aPid, int whatMib) {
+	void	*buf = NULL;
+	size_t	 len = 4096;
+	int	 rc = -1;
+	int	 managementInfoBase[4];
+
+        managementInfoBase[0] = CTL_KERN;
+        managementInfoBase[1] = KERN_PROC_ARGS;
+        managementInfoBase[2] = aPid;
+        managementInfoBase[3] = whatMib;
+
+	do
+	{
+	    len *= 2;
+	    nbuf = realloc(buf, len);
+	    if (nbuf == NULL)
+		break;
+	    buf = nbuf;
+	    rc = ssctl(managementInfoBase, 4, buf, &len, NULL, 0);
+	} while (rc == -1 && errno == ENOMEM);
+
+	if (rc == -1)
+	{
+	    free(buf);
+	    return NULL;
+	}
+
+	return (char**)buf;
+    }
+#endif
+
     virtual bool readArguments(int aPid) {
+#if defined(Q_OS_OPENBSD)
+	char **argv;
+#else
         char args[ARG_MAX];
         int managementInfoBase[4];
         size_t len;
+#endif
 
+#if defined(Q_OS_OPENBSD)
+	argv = readProcArgs(aPid, KERN_PROC_ARGV);
+	if (argv == NULL)
+	    return false;
+	for (const char **p = argv); *p != NULL; p++)
+	{
+	    addArgument(QString(*p));
+	}
+	free(argv);
+#else
         managementInfoBase[0] = CTL_KERN;
         managementInfoBase[1] = KERN_PROC;
         managementInfoBase[2] = KERN_PROC_PID;
@@ -675,28 +734,51 @@ class FreeBSDProcessInfo : public UnixProcessInfo (pri
         for (QStringList::const_iterator it = argumentList.begin(); it != argumentList.end(); ++it) {
             addArgument(*it);
         }
+#endif
 
         return true;
     }
 
     virtual bool readEnvironment(int aPid) {
+#if defined(Q_OS_OPENBSD)
+	char	**envp, *eqsign;
+
+	envp = readProcArgs(aPid, KERN_PROC_ENV);
+	if (envp == NULL)
+	    return false;
+	for (char **p = envp); *p != NULL; p++)
+	{
+	    eqsign = strchr(*p, '=');
+	    if (eqsign == NULL || eqsign[1] == '\0')
+		continue;
+	    *eqsign = '\0';
+	    addEnvironmentBinding(QString((const char *)p),
+		QString((const char *)eqsign + 1);
+	}
+	free(envp);
+	return true;
+#else
         // Not supported in FreeBSD?
         return false;
+#endif
     }
 
     virtual bool readCurrentDir(int aPid) {
-#if defined(__DragonFly__)
+#if defined(__DragonFly__) || defined(Q_OS_OPENBSD)
         char buf[PATH_MAX];
-        int managementInfoBase[4];
+        int i, managementInfoBase[4];
         size_t len;
 
-        managementInfoBase[0] = CTL_KERN;
-        managementInfoBase[1] = KERN_PROC;
-        managementInfoBase[2] = KERN_PROC_CWD;
-        managementInfoBase[3] = aPid;
+	i = 0;
+        managementInfoBase[i++] = CTL_KERN;
+#if defined(__DragonFly__)
+        managementInfoBase[i++] = KERN_PROC;
+#endif
+        managementInfoBase[i++] = KERN_PROC_CWD;
+        managementInfoBase[i++] = aPid;
 
         len = sizeof(buf);
-        if (sysctl(managementInfoBase, 4, buf, &len, NULL, 0) == -1)
+        if (sysctl(managementInfoBase, i, buf, &len, NULL, 0) == -1)
             return false;
 
         setCurrentDir(buf);
@@ -1049,8 +1131,8 @@ ProcessInfo* ProcessInfo::newInstance(int aPid, bool e
     return new SolarisProcessInfo(aPid, enableEnvironmentRead);
 #elif defined(Q_OS_MAC)
     return new MacProcessInfo(aPid, enableEnvironmentRead);
-#elif defined(Q_OS_FREEBSD)
-    return new FreeBSDProcessInfo(aPid, enableEnvironmentRead);
+#elif defined(Q_OS_FREEBSD) || defined(Q_OS_OPENBSD)
+    return new BSDProcessInfo(aPid, enableEnvironmentRead);
 #else
     return new NullProcessInfo(aPid, enableEnvironmentRead);
 #endif
