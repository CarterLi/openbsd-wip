$OpenBSD$
--- kdecore/util/kshareddatacache.cpp.orig	Wed Jun 20 01:45:52 2012
+++ kdecore/util/kshareddatacache.cpp	Wed Aug 22 21:20:22 2012
@@ -429,7 +429,7 @@ struct SharedMemory
      * 2. Any member variable you add takes up space in shared memory as well,
      * so make sure you need it.
      */
-    bool performInitialSetup(uint _cacheSize, uint _pageSize)
+    bool performInitialSetup(uint _cacheSize, uint _pageSize, int fd)
     {
         if (_cacheSize < MINIMUM_CACHE_SIZE) {
             kError(ksdcArea()) << "Internal error: Attempted to create a cache sized < "
@@ -449,19 +449,13 @@ struct SharedMemory
             return false;
         }
 
-        bool isProcessShared = false;
-        QSharedPointer<KSDCLock> tempLock(createLockFromId(shmLock.type, shmLock));
+        QSharedPointer<KSDCLock> tempLock(createLockFromId(shmLock.type, shmLock, fd));
 
-        if (!tempLock->initialize(isProcessShared)) {
+        if (!tempLock->initialize()) {
             kError(ksdcArea()) << "Unable to initialize the lock for the cache!";
             return false;
         }
 
-        if (!isProcessShared) {
-            kWarning(ksdcArea()) << "Cache initialized, but does not support being"
-                          << "shared across processes.";
-        }
-
         // These must be updated to make some of our auxiliary functions
         // work right since their values will be based on the cache size.
         cacheSize = _cacheSize;
@@ -1020,6 +1014,10 @@ class KSharedDataCache::Private
 
         shm = 0;
         m_mapSize = 0;
+
+        if (m_cache.handle() != -1) {
+            m_cache.close();
+        }
     }
 
     // This function does a lot of the important work, attempting to connect to shared
@@ -1038,7 +1036,7 @@ class KSharedDataCache::Private
 
         // The m_cacheName is used to find the file to store the cache in.
         QString cacheName = KGlobal::dirs()->locateLocal("cache", m_cacheName + QLatin1String(".kcache"));
-        QFile file(cacheName);
+        m_cache.setFileName(cacheName);
 
         // The basic idea is to open the file that we want to map into shared
         // memory, and then actually establish the mapping. Once we have mapped the
@@ -1058,14 +1056,14 @@ class KSharedDataCache::Private
         // We establish the shared memory mapping here, only if we will have appropriate
         // mutex support (systemSupportsProcessSharing), then we:
         // Open the file and resize to some sane value if the file is too small.
-        if (file.open(QIODevice::ReadWrite) &&
-           (file.size() >= size || file.resize(size)) &&
-           ensureFileAllocated(file.handle(), size))
+        if (m_cache.open(QIODevice::ReadWrite) &&
+           (m_cache.size() >= size || m_cache.resize(size)) &&
+           ensureFileAllocated(m_cache.handle(), size))
         {
             // Use mmap directly instead of QFile::map since the QFile (and its
             // shared mapping) will disappear unless we hang onto the QFile for no
             // reason (see the note below, we don't care about the file per se...)
-            mapAddress = ::mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED, file.handle(), 0);
+            mapAddress = ::mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED, m_cache.handle(), 0);
 
             // So... it is possible that someone else has mapped this cache already
             // with a larger size. If that's the case we need to at least match
@@ -1096,7 +1094,7 @@ class KSharedDataCache::Private
                     unsigned actualPageSize = mapped->cachePageSize();
                     ::munmap(mapAddress, size);
                     size = SharedMemory::totalSize(cacheSize, actualPageSize);
-                    mapAddress = ::mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED, file.handle(), 0);
+                    mapAddress = ::mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED, m_cache.handle(), 0);
                 }
             }
         }
@@ -1150,18 +1148,18 @@ class KSharedDataCache::Private
                 // Didn't acquire within ~8 seconds?  Assume an issue exists
                 kError(ksdcArea()) << "Unable to acquire shared lock, is the cache corrupt?";
 
-                file.remove(); // Unlink the cache in case it's corrupt.
+                m_cache.remove(); // Unlink the cache in case it's corrupt.
                 detachFromSharedMemory();
                 return; // Fallback to QCache (later)
             }
 
             if (shm->ready.testAndSetAcquire(0, 1)) {
-                if (!shm->performInitialSetup(cacheSize, pageSize)) {
+                if (!shm->performInitialSetup(cacheSize, pageSize, m_cache.handle())) {
                     kError(ksdcArea()) << "Unable to perform initial setup, this system probably "
                                    "does not really support process-shared pthreads or "
                                    "semaphores, even though it claims otherwise.";
 
-                    file.remove();
+                    m_cache.remove();
                     detachFromSharedMemory();
                     return;
                 }
@@ -1175,10 +1173,8 @@ class KSharedDataCache::Private
         }
 
         m_expectedType = shm->shmLock.type;
-        m_lock = QSharedPointer<KSDCLock>(createLockFromId(m_expectedType, shm->shmLock));
-        bool isProcessSharingSupported = false;
-
-        if (!m_lock->initialize(isProcessSharingSupported)) {
+        m_lock = QSharedPointer<KSDCLock>(createLockFromId(m_expectedType, shm->shmLock, m_cache.handle()));
+        if (!m_lock->initialize()) {
             kError(ksdcArea()) << "Unable to setup shared cache lock, although it worked when created.";
             detachFromSharedMemory();
         }
@@ -1299,7 +1295,7 @@ class KSharedDataCache::Private
                 // drop the map and (try to) re-establish.
                 d->unlock();
 
-#ifdef KSDC_MSYNC_SUPPORTED
+#ifdef HAVE_MSYNC
                 ::msync(d->shm, d->m_mapSize, MS_INVALIDATE | MS_ASYNC);
 #endif
                 ::munmap(d->shm, d->m_mapSize);
@@ -1348,6 +1344,7 @@ class KSharedDataCache::Private
     };
 
     QString m_cacheName;
+    QFile m_cache;
     QMutex m_threadLock;
     SharedMemory *shm;
     QSharedPointer<KSDCLock> m_lock;
@@ -1453,7 +1450,7 @@ KSharedDataCache::~KSharedDataCache()
     }
 
     if (d->shm) {
-#ifdef KSDC_MSYNC_SUPPORTED
+#ifdef HAVE_MSYNC
         ::msync(d->shm, d->m_mapSize, MS_INVALIDATE | MS_ASYNC);
 #endif
         ::munmap(d->shm, d->m_mapSize);
