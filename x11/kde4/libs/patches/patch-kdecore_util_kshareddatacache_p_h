$OpenBSD$
--- kdecore/util/kshareddatacache_p.h.orig	Wed May 23 11:00:55 2012
+++ kdecore/util/kshareddatacache_p.h	Thu Aug 23 00:00:58 2012
@@ -21,6 +21,7 @@
 #define KSHAREDDATACACHE_P_H
 
 #include <config.h> // HAVE_SYS_MMAN_H
+#include <config-util.h>
 
 #include <QtCore/QSharedPointer>
 
@@ -34,51 +35,18 @@
 // Our debug area, disabled by default
 int ksdcArea();
 
-// Mac OS X, for all its POSIX compliance, does not support timeouts on its
-// mutexes, which is kind of a disaster for cross-process support. However
-// synchronization primitives still work, they just might hang if the cache is
-// corrupted, so keep going.
-#if defined(_POSIX_TIMEOUTS) && ((_POSIX_TIMEOUTS == 0) || (_POSIX_TIMEOUTS >= 200112L))
-#define KSDC_TIMEOUTS_SUPPORTED 1
+#if defined(HAVE_LOCKF) || defined(HAVE_FLOCK)
+#define KSDC_FILELOCKS_SUPPORTED 1
 #endif
 
-#if defined(__GNUC__) && !defined(KSDC_TIMEOUTS_SUPPORTED)
-#warning "No support for POSIX timeouts -- application hangs are possible if the cache is corrupt"
-#endif
-
-#if defined(_POSIX_THREAD_PROCESS_SHARED) && ((_POSIX_THREAD_PROCESS_SHARED == 0) || (_POSIX_THREAD_PROCESS_SHARED >= 200112L)) && !defined(__APPLE__)
+#if defined(HAVE_SHARED_PTHREAD_MUTEXES) || defined(KSDC_FILELOCKS_SUPPORTED)
 #include <pthread.h>
-#define KSDC_THREAD_PROCESS_SHARED_SUPPORTED 1
 #endif
 
-#if defined(_POSIX_SEMAPHORES) && ((_POSIX_SEMAPHORES == 0) || (_POSIX_SEMAPHORES >= 200112L))
-#include <semaphore.h>
-#define KSDC_SEMAPHORES_SUPPORTED 1
-#endif
-
-#if defined(__GNUC__) && !defined(KSDC_SEMAPHORES_SUPPORTED) && !defined(KSDC_THREAD_PROCESS_SHARED_SUPPORTED)
+#if defined(__GNUC__) && !defined(HAVE_SHARED_PTHREAD_MUTEXES) && !defined(HAVE_SHARED_SEMAPHORES) && !defined(HAVE_GCC_SYNC) && !defined(KSDC_FILELOCKS_SUPPORTED)
 #warning "No system support claimed for process-shared synchronization, KSharedDataCache will be mostly useless."
 #endif
 
-#if defined(_POSIX_MAPPED_FILES) && ((_POSIX_MAPPED_FILES == 0) || (_POSIX_MAPPED_FILES >= 200112L))
-#define KSDC_MAPPED_FILES_SUPPORTED 1
-#endif
-
-#if defined(_POSIX_SYNCHRONIZED_IO) && ((_POSIX_SYNCHRONIZED_IO == 0) || (_POSIX_SYNCHRONIZED_IO >= 200112L))
-#define KSDC_SYNCHRONIZED_IO_SUPPORTED 1
-#endif
-
-// msync(2) requires both MAPPED_FILES and SYNCHRONIZED_IO POSIX options
-#if defined(KSDC_MAPPED_FILES_SUPPORTED) && defined(KSDC_SYNCHRONIZED_IO_SUPPORTED)
-#define KSDC_MSYNC_SUPPORTED
-#endif
-
-// posix_fallocate is used to ensure that the file used for the cache is
-// actually fully committed to disk before attempting to use the file.
-#if defined(_POSIX_ADVISORY_INFO) && ((_POSIX_ADVISORY_INFO == 0) || (_POSIX_ADVISORY_INFO >= 200112L))
-#define KSDC_POSIX_FALLOCATE_SUPPORTED 1
-#endif
-
 // BSD/Mac OS X compat
 #ifdef HAVE_SYS_MMAN_H
 #include <sys/mman.h>
@@ -87,6 +55,11 @@ int ksdcArea();
 #define MAP_ANONYMOUS MAP_ANON
 #endif
 
+// Some locks implement timing out, define it's length here (in seconds)
+enum {
+    KSDC_WAIT_TIMEOUT = 10,
+};
+
 /**
  * This class defines an interface used by KSharedDataCache::Private to offload
  * proper locking and unlocking depending on what the platform supports at
@@ -100,9 +73,8 @@ class KSDCLock { (public)
 
     // Return value indicates if the mutex was properly initialized (including
     // threads-only as a fallback).
-    virtual bool initialize(bool &processSharingSupported)
+    virtual bool initialize()
     {
-        processSharingSupported = false;
         return false;
     }
 
@@ -116,7 +88,256 @@ class KSDCLock { (public)
     }
 };
 
-#ifdef KSDC_THREAD_PROCESS_SHARED_SUPPORTED
+#ifdef HAVE_GCC_SYNC
+/**
+ * This is a very basic lock that should work on any system where GCC atomic
+ * intrinsics are supported. It can waste CPU so better primitives should be
+ * used if available on the system.
+ */
+class simpleSpinLock : public KSDCLock
+{
+public:
+    simpleSpinLock(int &spinlock)
+        : m_spinlock(spinlock)
+    {
+        __sync_synchronize();
+    }
+
+    virtual bool initialize()
+    {
+        // Clear the spinlock
+        __sync_fetch_and_and(&m_spinlock, 0);
+        return true;
+    }
+
+    virtual bool lock()
+    {
+#ifdef HAVE_MONOTONIC_CLOCK
+        struct timespec start, t;
+
+        if (::clock_gettime(CLOCK_MONOTONIC, &start) == -1) {
+            kError(ksdcArea()) << "clock_gettime(CLOCK_MONOTONIC, ...) failed, errno:" << errno;
+            return false;
+        }
+        do {
+            if (__sync_lock_test_and_set(&m_spinlock, 1) == 0) {
+                return true;
+            }
+
+            if (::clock_gettime(CLOCK_MONOTONIC, &t) == -1) {
+                kError(ksdcArea()) << "clock_gettime(CLOCK_MONOTONIC, ...) failed, errno:" << errno;
+                return false;
+            }
+	} while (t.tv_sec <= start.tv_sec - KSDC_WAIT_TIMEOUT && t.tv_nsec < start.tv_nsec);
+#else
+        // Monotonic clock is not supported, KSharedDataCache could misbehave
+        // on time change. Not critical, though, so no warning here.
+        time_t start = ::time(NULL);
+        int i = 1;
+
+	do {
+            if (__sync_lock_test_and_set(&m_spinlock, 1) == 0) {
+                return true;
+            }
+        } while (::time(NULL) < start + KSDC_WAIT_TIMEOUT);
+#endif
+        kDebug(ksdcArea()) << "spinlock timed out";
+        return false;
+    }
+
+    virtual void unlock()
+    {
+        __sync_lock_release(&m_spinlock);
+    }
+
+private:
+    int &m_spinlock;
+};
+#endif    // HAVE_GCC_SYNC
+
+#ifdef KSDC_FILELOCKS_SUPPORTED
+// Implement locking via native file locking mechanisms.
+// Prefer flock() over lockf() because flock() locks do not release when any
+// descriptor for this file (inode) is closed.
+// See "Everything you never wanted to know about file locking"
+// http://apenwarr.ca/log/?m=201012#13 for details.
+class fileLock : public KSDCLock
+{
+public:
+    // Duplicate to make sure position doesn't change
+    fileLock(int fd)
+        : m_fd(::dup(fd)),
+          m_initialized(false)
+    {
+        kDebug(ksdcArea()) << "created on fd" << m_fd;
+    }
+
+    virtual ~fileLock() {
+        kWarning(ksdcArea()) << "destroying";
+        if (m_initialized) {
+            int rc = ::pthread_mutex_destroy(&m_mutex);
+            if (rc != 0) {
+                kError(ksdcArea()) << "pthread_mutex_destroy failed, errno:" << rc;
+            }
+        }
+        if (m_fd != -1 && ::close(m_fd) == -1) {
+            kError(ksdcArea()) << "close failed, errno:" << errno;
+        }
+    }
+
+    // This technically should be done in constructor instead because our data
+    // does not lie in shared memory, but we want to fail gracefully. So we'll
+    // check in lock() below if we're actually initialized.
+    virtual bool initialize()
+    {
+        int rc;
+
+        kDebug(ksdcArea()) << "called";
+
+#ifdef HAVE_FLOCK
+        // In case of flock() we obviously should avoid child inheriting any acquired locks.
+        // Probably not a problem for KDE but it's better to be safe than sorry.
+        if (::fcntl(m_fd, F_SETFD, FD_CLOEXEC) == -1) {
+            kError(ksdcArea()) << "fcntl(" << m_fd << ", F_SETFD, FD_CLOEXEC) failed, errno:" << errno;
+            return false;
+        }
+#endif
+
+        // Make sure we lock entire file
+        if (::lseek(m_fd, 0, SEEK_SET) == -1) {
+            kError(ksdcArea()) << "lseek failed, errno:" << errno;
+            return false;
+        }
+
+        rc = ::pthread_mutex_init(&m_mutex, NULL);
+        if (rc != 0) {
+            kError(ksdcArea()) << "pthread_mutex_init failed, errno:" << rc;
+            return false;
+        }
+
+        m_initialized = true;
+        kDebug(ksdcArea()) << "success";
+        return true;
+    }
+
+    virtual bool lock()
+    {
+#ifdef HAVE_PTHREAD_TIMEOUTS
+        struct timespec timeout;
+#endif
+        int flags, rc;
+
+        kDebug(ksdcArea()) << "called";
+
+        if (m_fd == -1) {
+            kWarning(ksdcArea()) << "file descriptor is closed, lock failed";
+            return false;
+        }
+
+        // initialize() is called only after cache creation
+        if (!m_initialized) {
+            if (!initialize()) {
+                kError(ksdcArea()) << "initialization failed, lock failed";
+                return false;
+            }
+        }
+
+        // We use two locks: file lock for process-shared locking and simple
+        // mutex for thread-sharing.
+        //
+        // First acquire smaller lock (thread-level), then try bigger one
+        // (process level). Otherwise the following could happen:
+        //   1. Process 1000, thread 1 (1000/1 later) acquires both locks
+        //   2. Process 2000 tries to acquire file lock and starts waiting.
+        //   3. Process 1000/2 successfully acquires file lock and starts
+        //      waiting on thread lock.
+        //   4a. Process 1000/1 frees file lock, then thread lock: PID 2000
+        //       acquires file lock but process 1000/2 still thinks it acquired
+        //       file lock too. Now both 1000/2 and 2000 acquire thread locks in
+        //       their processes and go async. Kaboom.
+        //   4b. Process 1000/1 frees thread lock, then file lock: 1000/2
+        //       acquires file lock and then 1000/1 frees it, allowing 2000 to
+        //       join the game too. Now both 1000/2 and 2000 will both acquire
+        //       thread locks... you already know what happens next.
+
+#ifdef HAVE_PTHREAD_TIMEOUTS
+        timeout.tv_sec = KSDC_WAIT_TIMEOUT;
+        timeout.tv_nsec = 0;
+        rc = ::pthread_mutex_timedlock(&m_mutex, &timeout);
+#else
+        rc = ::pthread_mutex_lock(&m_mutex);
+#endif
+        if (rc != 0) {
+            if (rc == EBUSY) {
+                kDebug(ksdcArea()) << "thread lock is busy";
+            } else {
+                kError(ksdcArea()) << "thread lock failed, errno:" << rc;
+            }
+            return false;
+        }
+
+#ifdef HAVE_FLOCK
+        rc = ::flock(m_fd, LOCK_EX);
+#else
+        rc = ::lockf(m_fd, F_LOCK, 0);
+#endif
+        if (rc == -1) {
+            if (errno == EAGAIN) {
+                kDebug(ksdcArea()) << "file lock is busy";
+            } else {
+                if (errno == EBADF) {
+                    m_fd = -1;    // do not try to lock it anymore
+                }
+                kError(ksdcArea()) << "file lock failed, errno:" << errno;
+            }
+            ::pthread_mutex_unlock(&m_mutex);
+            return false;
+        }
+
+        kDebug(ksdcArea()) << "locked successfully";
+        return true;
+    }
+
+    virtual void unlock()
+    {
+        int rc;
+
+        kDebug(ksdcArea()) << "called";
+
+        if (m_fd == -1) {
+            kWarning(ksdcArea()) << "file descriptor is closed, fail to unlock";
+            return;
+        }
+
+        // Proceed with locks in the reverse order relative to lock()
+
+#ifdef HAVE_FLOCK
+        rc = ::flock(m_fd, LOCK_UN);
+#else
+        rc = ::lockf(m_fd, F_ULOCK, 0);
+#endif
+        if (rc == -1) {
+            if (errno == EBADF) {
+                m_fd = -1;    // do not try to lock it anymore
+            }
+            kError(ksdcArea()) << "file unlock failed, errno:" << errno;
+        }
+
+        rc = ::pthread_mutex_unlock(&m_mutex);
+        if (rc != 0) {
+            kError(ksdcArea()) << "pthread_mutex_unlock failed, errno:" << rc;
+        }
+    }
+
+protected:
+    int m_fd;
+    pthread_mutex_t m_mutex;
+private:
+    bool m_initialized;
+};
+#endif    // KSDC_FILELOCKS_SUPPORTED
+
+#ifdef HAVE_SHARED_PTHREAD_MUTEXES
 class pthreadLock : public KSDCLock
 {
 public:
@@ -125,47 +346,49 @@ class pthreadLock : public KSDCLock (public)
     {
     }
 
-    virtual bool initialize(bool &processSharingSupported)
+    virtual bool initialize()
     {
-        // Setup process-sharing.
+        int rc;
         pthread_mutexattr_t mutexAttr;
-        processSharingSupported = false;
 
-        // Initialize attributes, enable process-shared primitives, and setup
-        // the mutex.
-        if (::sysconf(_SC_THREAD_PROCESS_SHARED) >= 200112L && pthread_mutexattr_init(&mutexAttr) == 0) {
-            if (pthread_mutexattr_setpshared(&mutexAttr, PTHREAD_PROCESS_SHARED) == 0 &&
-                pthread_mutex_init(&m_mutex, &mutexAttr) == 0)
-            {
-                processSharingSupported = true;
-            }
-            pthread_mutexattr_destroy(&mutexAttr);
+        // Setup process-sharing.
+        rc = ::pthread_mutexattr_setpshared(&mutexAttr, PTHREAD_PROCESS_SHARED);
+        if (rc != 0) {
+            kError(ksdcArea()) << "pthread_mutexattr_setpshared failed, errno:" << rc;
+            return false;
         }
 
-        // Attempt to setup for thread-only synchronization.
-        if (!processSharingSupported && pthread_mutex_init(&m_mutex, NULL) != 0) {
+        rc = ::pthread_mutex_init(&m_mutex, &mutexAttr);
+        if (rc != 0) {
+            kError(ksdcArea()) << "pthread_mutex_init failed, errno:" << rc;
             return false;
         }
 
+        ::pthread_mutexattr_destroy(&mutexAttr);
         return true;
     }
 
     virtual bool lock()
     {
-        return pthread_mutex_lock(&m_mutex) == 0;
+        int rc = ::pthread_mutex_lock(&m_mutex);
+        if (rc == -1) {
+            kError(ksdcArea()) << "pthread_mutex_lock failed, errno:" << rc;
+            return false;
+        }
+        return true;
     }
 
     virtual void unlock()
     {
-        pthread_mutex_unlock(&m_mutex);
+        ::pthread_mutex_unlock(&m_mutex);
     }
 
 protected:
     pthread_mutex_t &m_mutex;
 };
-#endif
+#endif    // defined(HAVE_SHARED_PTHREAD_MUTEXES)
 
-#if defined(KSDC_THREAD_PROCESS_SHARED_SUPPORTED) && defined(KSDC_TIMEOUTS_SUPPORTED)
+#if defined(HAVE_SHARED_PTHREAD_MUTEXES) && defined(HAVE_PTHREAD_TIMEOUTS)
 class pthreadTimedLock : public pthreadLock
 {
 public:
@@ -177,19 +400,25 @@ class pthreadTimedLock : public pthreadLock (public)
     virtual bool lock()
     {
         struct timespec timeout;
+        int rc;
 
         // Long timeout, but if we fail to meet this timeout it's probably a cache
         // corruption (and if we take 8 seconds then it should be much much quicker
         // the next time anyways since we'd be paged back in from disk)
-        timeout.tv_sec = 10 + ::time(NULL); // Absolute time, so 10 seconds from now
+        timeout.tv_sec = KSDC_WAIT_TIMEOUT + ::time(NULL); // Absolute time, so count from now
         timeout.tv_nsec = 0;
 
-        return pthread_mutex_timedlock(&m_mutex, &timeout) >= 0;
+        rc = pthread_mutex_timedlock(&m_mutex, &timeout);
+        if (rc == -1)
+            kError(ksdcArea()) << "pthread_mutex_timedlock failed, errno:" << rc;
+            return false;
+        }
+        return true;
     }
 };
-#endif
+#endif    // defined(HAVE_SHARED_PTHREAD_MUTEXES) && defined(HAVE_PTHREAD_TIMEOUTS)
 
-#ifdef KSDC_SEMAPHORES_SUPPORTED
+#ifdef HAVE_SHARED_SEMAPHORES
 class semaphoreLock : public KSDCLock
 {
 public:
@@ -198,41 +427,35 @@ class semaphoreLock : public KSDCLock (public)
     {
     }
 
-    virtual bool initialize(bool &processSharingSupported)
+    virtual bool initialize()
     {
-        processSharingSupported = false;
-        if (::sysconf(_SC_SEMAPHORES) < 200112L) {
+        if (::sem_init(&m_semaphore, 1, 1) == -1) {
+            kError(ksdcArea()) << "sem_init() failed, errno:" << errno;
             return false;
         }
-
-        // sem_init sets up process-sharing for us.
-        if (sem_init(&m_semaphore, 1, 1) == 0) {
-            processSharingSupported = true;
-        }
-        // If not successful try falling back to thread-shared.
-        else if (sem_init(&m_semaphore, 0, 1) != 0) {
-            return false;
-        }
-
         return true;
     }
 
     virtual bool lock()
     {
-        return sem_wait(&m_semaphore) == 0;
+        if (::sem_wait(&m_semaphore) == -1) {
+            kError(ksdcArea()) << "sem_wait() failed, errno:" << errno;
+            return false;
+        }
+        return true;
     }
 
     virtual void unlock()
     {
-        sem_post(&m_semaphore);
+        ::sem_post(&m_semaphore);
     }
 
 protected:
     sem_t &m_semaphore;
 };
-#endif
+#endif    // HAVE_SHARED_SEMAPHORES
 
-#if defined(KSDC_SEMAPHORES_SUPPORTED) && defined(KSDC_TIMEOUTS_SUPPORTED)
+#if defined(HAVE_SHARED_SEMAPHORES_TIMEOUTS)
 class semaphoreTimedLock : public semaphoreLock
 {
 public:
@@ -243,18 +466,24 @@ class semaphoreTimedLock : public semaphoreLock (publi
 
     virtual bool lock()
     {
+        int rc;
         struct timespec timeout;
 
         // Long timeout, but if we fail to meet this timeout it's probably a cache
         // corruption (and if we take 8 seconds then it should be much much quicker
         // the next time anyways since we'd be paged back in from disk)
-        timeout.tv_sec = 10 + ::time(NULL); // Absolute time, so 10 seconds from now
+        timeout.tv_sec = KSDC_WAIT_TIMEOUT + ::time(NULL); // Absolute time, so 10 seconds from now
         timeout.tv_nsec = 0;
 
-        return sem_timedwait(&m_semaphore, &timeout) == 0;
+        rc = ::sem_timedwait(&m_semaphore, &timeout);
+        if (rc == -1) {
+            kError(ksdcArea()) << "sem_timedwait() failed, errno:" << errno;
+            return false;
+        }
+        return true;
     }
 };
-#endif
+#endif    // HAVE_SHARED_SEMAPHORES_TIMEOUTS
 
 // This enum controls the type of the locking used for the cache to allow
 // for as much portability as possible. This value will be stored in the
@@ -263,7 +492,9 @@ class semaphoreTimedLock : public semaphoreLock (publi
 enum SharedLockId {
     LOCKTYPE_INVALID   = 0,
     LOCKTYPE_MUTEX     = 1,  // pthread_mutex
-    LOCKTYPE_SEMAPHORE = 2   // sem_t
+    LOCKTYPE_SEMAPHORE = 2,  // sem_t
+    LOCKTYPE_FILE      = 3,  // pthread_mutex_t+int (not a ref to shared memory)
+    LOCKTYPE_SPIN      = 4,  // int
 };
 
 // This type is a union of all possible lock types, with a SharedLockId used
@@ -272,18 +503,26 @@ struct SharedLock
 {
     union
     {
-#if defined(KSDC_THREAD_PROCESS_SHARED_SUPPORTED)
+#if defined(HAVE_SHARED_PTHREAD_MUTEXES)
         pthread_mutex_t mutex;
 #endif
-#if defined(KSDC_SEMAPHORES_SUPPORTED)
+#if defined(HAVE_SHARED_SEMAPHORES)
         sem_t semaphore;
 #endif
+#if defined(HAVE_GCC_SYNC)
+        // What we really want is a plain QAtomicInt (not a pointer), but that
+        // requires using a POD type, which QAtomicInt does not qualify as.
+        // With C++11 we could just use language-based atomics though...
+        // In the interim, use GCC intrinsics (supported on most other
+        // compilers) with a plain int.
+        int spinlock;
+#endif
 
         // It would be highly unfortunate if a simple glibc upgrade or kernel
         // addition caused this structure to change size when an existing
         // lock was thought present, so reserve enough size to cover any
         // reasonable locking structure
-        char unused[64];
+        char unused[64 - sizeof(int)];
     };
 
     SharedLockId type;
@@ -293,106 +532,72 @@ struct SharedLock
  * This is a method to determine the best lock type to use for a
  * shared cache, based on local support. An identifier to the appropriate
  * SharedLockId is returned, which can be passed to createLockFromId().
+ * It's better to recreate cache than to allow program hang, so make blocking
+ * locks the lowest priority. Also, thread-only locks do not work at all, so
+ * don't use them. The actual order of preference looks like the following:
+ *   1. Process-shared locks with timeout support
+ *   2. Spin locks
+ *   3. File locks with (semi-)timeout support
+ *   4. Blocking process-shared locks
+ *   5. Blocking file locks
  */
 static SharedLockId findBestSharedLock()
 {
-    // We would prefer a process-shared capability that also supports
-    // timeouts. Failing that, process-shared is preferred over timeout
-    // support. Failing that we'll go thread-local
-    bool pthreadsSupported = false;
-    bool semaphoresSupported = false;
-    bool timeoutsSupported = false;
-    bool pthreadsProcessShared = false;
-    bool semaphoresProcessShared = false;
+#if defined(HAVE_SHARED_PTHREAD_MUTEXES) && defined(HAVE_PTHREAD_TIMEOUTS)
+    return LOCKTYPE_MUTEX;
+#elif defined(HAVE_SHARED_SEMAPHORES_TIMEOUTS)
+    return LOCKTYPE_SEMAPHORE;
+#elif defined(HAVE_GCC_SYNC)
+    return LOCKTYPE_SPIN;
+#else
+# if defined(__GNUC__)
+# warning "No support for locks with timeouts -- application hangs are possible."
+# endif
 
-#ifdef KSDC_TIMEOUTS_SUPPORTED
-    timeoutsSupported = ::sysconf(_SC_TIMEOUTS) >= 200112L;
-#endif
-
-    // Now that we've queried timeouts, try actually creating real locks and
-    // seeing if there's issues with that.
-#ifdef KSDC_THREAD_PROCESS_SHARED_SUPPORTED
-    {
-        pthread_mutex_t tempMutex;
-        QSharedPointer<KSDCLock> tempLock(0);
-        if (timeoutsSupported) {
-#ifdef KSDC_TIMEOUTS_SUPPORTED
-            tempLock = QSharedPointer<KSDCLock>(new pthreadTimedLock(tempMutex));
-#endif
-        }
-        else {
-            tempLock = QSharedPointer<KSDCLock>(new pthreadLock(tempMutex));
-        }
-
-        pthreadsSupported = tempLock->initialize(pthreadsProcessShared);
-    }
-#endif
-
-    // Our first choice is pthread_mutex_t for compatibility.
-    if(timeoutsSupported && pthreadsProcessShared) {
-        return LOCKTYPE_MUTEX;
-    }
-
-#ifdef KSDC_SEMAPHORES_SUPPORTED
-    {
-        sem_t tempSemaphore;
-        QSharedPointer<KSDCLock> tempLock(0);
-        if (timeoutsSupported) {
-            tempLock = QSharedPointer<KSDCLock>(new semaphoreTimedLock(tempSemaphore));
-        }
-        else {
-            tempLock = QSharedPointer<KSDCLock>(new semaphoreLock(tempSemaphore));
-        }
-
-        semaphoresSupported = tempLock->initialize(semaphoresProcessShared);
-    }
-#endif
-
-    if(timeoutsSupported && semaphoresProcessShared) {
-        return LOCKTYPE_SEMAPHORE;
-    }
-    else if(pthreadsProcessShared) {
-        return LOCKTYPE_MUTEX;
-    }
-    else if(semaphoresProcessShared) {
-        return LOCKTYPE_SEMAPHORE;
-    }
-    else if(pthreadsSupported) {
-        return LOCKTYPE_MUTEX;
-    }
-    else if(semaphoresSupported) {
-        return LOCKTYPE_SEMAPHORE;
-    }
-
+# if defined(KSDC_HAVE_FILELOCKS)
+    return LOCKTYPE_FILE;
+# elif defined(HAVE_SHARED_PTHREAD_MUTEXES)
+    return LOCKTYPE_MUTEX;
+# elif defined(HAVE_SHARED_SEMAPHORES)
+    return LOCKTYPE_SEMAPHORE;
+# else
     // If we get to this point we'll likely fail later but this is the
     // standard behavior that has existed as well, so...
-    return static_cast<SharedLockId>(0);
+    return LOCKTYPE_INVALID;
+# endif
+#endif
 }
 
-static KSDCLock *createLockFromId(SharedLockId id, SharedLock &lock)
+static KSDCLock *createLockFromId(SharedLockId id, SharedLock &lock, int fd)
 {
     switch(id) {
-#ifdef KSDC_THREAD_PROCESS_SHARED_SUPPORTED
-    case LOCKTYPE_MUTEX:
-#ifdef KSDC_TIMEOUTS_SUPPORTED
-        if (::sysconf(_SC_TIMEOUTS) >= 200112L) {
-            return new pthreadTimedLock(lock.mutex);
-        }
+#ifdef KSDC_FILELOCKS_SUPPORTED
+    case LOCKTYPE_FILE:
+        return new fileLock(fd);
 #endif
-        return new pthreadLock(lock.mutex);
 
+#ifdef HAVE_GCC_SYNC
+    case LOCKTYPE_SPIN:
+        return new simpleSpinLock(lock.spinlock);
+#endif
+
+#ifdef HAVE_SHARED_PTHREAD_MUTEXES
+    case LOCKTYPE_MUTEX:
+# ifdef HAVE_PTHREAD_TIMEOUTS
+        return new pthreadTimedLock(lock.mutex);
+# else
+        return new pthreadLock(lock.mutex);
+# endif
     break;
 #endif
 
-#ifdef KSDC_SEMAPHORES_SUPPORTED
+#ifdef HAVE_SHARED_SEMAPHORES
     case LOCKTYPE_SEMAPHORE:
-#ifdef KSDC_TIMEOUTS_SUPPORTED
-        if (::sysconf(_SC_SEMAPHORES) >= 200112L) {
-            return new semaphoreTimedLock(lock.semaphore);
-        }
-#endif
+# ifdef HAVE_SHARED_SEMAPHORES_TIMEOUTS
+        return new semaphoreTimedLock(lock.semaphore);
+# else
         return new semaphoreLock(lock.semaphore);
-
+# endif
     break;
 #endif
 
@@ -404,11 +609,13 @@ static KSDCLock *createLockFromId(SharedLockId id, Sha
 
 static bool ensureFileAllocated(int fd, size_t fileSize)
 {
-#ifdef KSDC_POSIX_FALLOCATE_SUPPORTED
+#ifdef HAVE_POSIX_FALLOCATE
+    // posix_fallocate is used to ensure that the file used for the cache is
+    // actually fully committed to disk before attempting to use the file.
     int result;
-    while ((result = ::posix_fallocate(fd, 0, fileSize)) == EINTR) {
-        ;
-    }
+    do {
+        result = ::posix_fallocate(fd, 0, fileSize);
+    } while (result == -1 && errno == EINTR);
 
     if (result < 0) {
         kError(ksdcArea()) << "The operating system is unable to promise"
