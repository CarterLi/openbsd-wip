$OpenBSD$
--- kdecore/util/kshareddatacache_p.h.orig	Wed May 23 11:00:55 2012
+++ kdecore/util/kshareddatacache_p.h	Mon Aug 27 23:01:39 2012
@@ -20,7 +20,7 @@
 #ifndef KSHAREDDATACACHE_P_H
 #define KSHAREDDATACACHE_P_H
 
-#include <config.h> // HAVE_SYS_MMAN_H
+#include <config-util.h> // HAVE_SYS_MMAN_H
 
 #include <QtCore/QSharedPointer>
 
@@ -34,59 +34,51 @@
 // Our debug area, disabled by default
 int ksdcArea();
 
-// Mac OS X, for all its POSIX compliance, does not support timeouts on its
-// mutexes, which is kind of a disaster for cross-process support. However
-// synchronization primitives still work, they just might hang if the cache is
-// corrupted, so keep going.
-#if defined(_POSIX_TIMEOUTS) && ((_POSIX_TIMEOUTS == 0) || (_POSIX_TIMEOUTS >= 200112L))
-#define KSDC_TIMEOUTS_SUPPORTED 1
+#if (HAVE_FLOCK || HAVE_LOCKF) && HAVE_PTHREAD_MUTEXES
+#define KSDC_FILELOCKS_SUPPORTED 1
+#else
+#define KSDC_FILELOCKS_SUPPORTED 0
 #endif
 
-#if defined(__GNUC__) && !defined(KSDC_TIMEOUTS_SUPPORTED)
-#warning "No support for POSIX timeouts -- application hangs are possible if the cache is corrupt"
+#if defined(__GNUC__) && !HAVE_SHARED_PTHREAD_MUTEXES_TIMEOUTS && !HAVE_SHARED_SEMAPHORES_TIMEOUTS
+#warning "No support for POSIX process-shared timeouts -- application hangs are possible."
 #endif
 
-#if defined(_POSIX_THREAD_PROCESS_SHARED) && ((_POSIX_THREAD_PROCESS_SHARED == 0) || (_POSIX_THREAD_PROCESS_SHARED >= 200112L)) && !defined(__APPLE__)
-#include <pthread.h>
-#define KSDC_THREAD_PROCESS_SHARED_SUPPORTED 1
-#endif
-
-#if defined(_POSIX_SEMAPHORES) && ((_POSIX_SEMAPHORES == 0) || (_POSIX_SEMAPHORES >= 200112L))
-#include <semaphore.h>
-#define KSDC_SEMAPHORES_SUPPORTED 1
-#endif
-
-#if defined(__GNUC__) && !defined(KSDC_SEMAPHORES_SUPPORTED) && !defined(KSDC_THREAD_PROCESS_SHARED_SUPPORTED)
+#if defined(__GNUC__) && !HAVE_SHARED_PTHREAD_MUTEXES && !HAVE_SHARED_SEMAPHORES && !KSDC_FILELOCKS_SUPPORTED
 #warning "No system support claimed for process-shared synchronization, KSharedDataCache will be mostly useless."
 #endif
 
-#if defined(_POSIX_MAPPED_FILES) && ((_POSIX_MAPPED_FILES == 0) || (_POSIX_MAPPED_FILES >= 200112L))
-#define KSDC_MAPPED_FILES_SUPPORTED 1
+#if HAVE_SHARED_PTHREAD_MUTEXES || KSDC_FILELOCKS_SUPPORTED
+#include <pthread.h>
 #endif
-
-#if defined(_POSIX_SYNCHRONIZED_IO) && ((_POSIX_SYNCHRONIZED_IO == 0) || (_POSIX_SYNCHRONIZED_IO >= 200112L))
-#define KSDC_SYNCHRONIZED_IO_SUPPORTED 1
+#if HAVE_SHARED_SEMAPHORES
+#include <semaphore.h>
 #endif
 
-// msync(2) requires both MAPPED_FILES and SYNCHRONIZED_IO POSIX options
-#if defined(KSDC_MAPPED_FILES_SUPPORTED) && defined(KSDC_SYNCHRONIZED_IO_SUPPORTED)
-#define KSDC_MSYNC_SUPPORTED
-#endif
-
-// posix_fallocate is used to ensure that the file used for the cache is
-// actually fully committed to disk before attempting to use the file.
-#if defined(_POSIX_ADVISORY_INFO) && ((_POSIX_ADVISORY_INFO == 0) || (_POSIX_ADVISORY_INFO >= 200112L))
-#define KSDC_POSIX_FALLOCATE_SUPPORTED 1
-#endif
-
 // BSD/Mac OS X compat
-#ifdef HAVE_SYS_MMAN_H
+#if HAVE_SYS_MMAN_H
 #include <sys/mman.h>
 #endif
 #if !defined(MAP_ANONYMOUS) && defined(MAP_ANON)
 #define MAP_ANONYMOUS MAP_ANON
 #endif
 
+enum {
+    KSDC_WAIT_TIMEOUT = 10,     // Lock timeout value, if supported
+};
+
+
+void ksdcErrOut(const char *funcname, int errcode)
+{
+#if HAVE_STRERROR_R
+    char errstr[NL_TEXTMAX];
+    strerror_r(errcode, errstr, sizeof(errstr));
+    kError(ksdcArea()) << funcname << "failed:" << errstr;
+#else
+    kError(ksdcArea()) << funcname << "failed, error code:" << errcode;
+#endif
+}
+
 /**
  * This class defines an interface used by KSharedDataCache::Private to offload
  * proper locking and unlocking depending on what the platform supports at
@@ -98,11 +90,9 @@ class KSDCLock { (public)
     {
     }
 
-    // Return value indicates if the mutex was properly initialized (including
-    // threads-only as a fallback).
-    virtual bool initialize(bool &processSharingSupported)
+    // Return value indicates if the mutex was properly initialized.
+    virtual bool initialize()
     {
-        processSharingSupported = false;
         return false;
     }
 
@@ -116,7 +106,7 @@ class KSDCLock { (public)
     }
 };
 
-#ifdef KSDC_THREAD_PROCESS_SHARED_SUPPORTED
+#if HAVE_SHARED_PTHREAD_MUTEXES
 class pthreadLock : public KSDCLock
 {
 public:
@@ -125,47 +115,55 @@ class pthreadLock : public KSDCLock (public)
     {
     }
 
-    virtual bool initialize(bool &processSharingSupported)
+    virtual bool initialize()
     {
-        // Setup process-sharing.
         pthread_mutexattr_t mutexAttr;
-        processSharingSupported = false;
+        int rc;
+        bool ok;
 
-        // Initialize attributes, enable process-shared primitives, and setup
-        // the mutex.
-        if (::sysconf(_SC_THREAD_PROCESS_SHARED) >= 200112L && pthread_mutexattr_init(&mutexAttr) == 0) {
-            if (pthread_mutexattr_setpshared(&mutexAttr, PTHREAD_PROCESS_SHARED) == 0 &&
-                pthread_mutex_init(&m_mutex, &mutexAttr) == 0)
-            {
-                processSharingSupported = true;
-            }
-            pthread_mutexattr_destroy(&mutexAttr);
-        }
-
-        // Attempt to setup for thread-only synchronization.
-        if (!processSharingSupported && pthread_mutex_init(&m_mutex, NULL) != 0) {
+        if ((rc = ::pthread_mutexattr_init(&mutexAttr)) != 0) {
+            ksdcErrOut("pthread_mutexattr_init", rc);
             return false;
         }
-
-        return true;
+        ok = true;
+        if ((rc = ::pthread_mutexattr_setpshared(&mutexAttr)) != 0) {
+            ksdcErrOut("pthread_mutexattr_setpshared", rc);
+            ok = false;
+        }
+        if (ok && (rc = ::pthread_mutex_init(&m_mutex, &mutex)) != 0) {
+            ksdcErrOut("pthread_mutex_init", rc);
+            ok = false;
+        }
+        ::pthread_mutexattr_destroy(&mutexAttr);
+        return ok;
     }
 
     virtual bool lock()
     {
-        return pthread_mutex_lock(&m_mutex) == 0;
+        int rc;
+
+        if ((rc = ::pthread_mutex_lock(&m_mutex)) != 0) {
+            ksdcErrOut("pthread_mutex_lock", rc);
+            return false;
+        }
+        return true;
     }
 
     virtual void unlock()
     {
-        pthread_mutex_unlock(&m_mutex);
+        int rc;
+
+        if ((rc = ::pthread_mutex_unlock(&m_mutex)) != 0) {
+            ksdcErrOut("pthread_mutex_unlock", rc);
+        }
     }
 
 protected:
     pthread_mutex_t &m_mutex;
 };
-#endif
+#endif    // HAVE_SHARED_PTHREAD_MUTEXES
 
-#if defined(KSDC_THREAD_PROCESS_SHARED_SUPPORTED) && defined(KSDC_TIMEOUTS_SUPPORTED)
+#if HAVE_SHARED_PTHREAD_MUTEXES_TIMEOUTS
 class pthreadTimedLock : public pthreadLock
 {
 public:
@@ -181,15 +179,23 @@ class pthreadTimedLock : public pthreadLock (public)
         // Long timeout, but if we fail to meet this timeout it's probably a cache
         // corruption (and if we take 8 seconds then it should be much much quicker
         // the next time anyways since we'd be paged back in from disk)
-        timeout.tv_sec = 10 + ::time(NULL); // Absolute time, so 10 seconds from now
+        timeout.tv_sec = KSDC_WAIT_TIMEOUT + ::time(NULL); // Absolute time, so count from now
         timeout.tv_nsec = 0;
 
-        return pthread_mutex_timedlock(&m_mutex, &timeout) >= 0;
+        if ((rc = ::pthread_mutex_timedlock(&mutex, &timeout)) != 0) {
+            if (rc == ETIMEDOUT) {
+                kWarning(ksdcArea()) << "pthread_mutex_timedlock timed out";
+            } else {
+                ksdcErrOut("pthread_mutex_unlock", rc);
+            }
+            return false;
+        }
+        return true;
     }
 };
-#endif
+#endif    // HAVE_SHARED_PTHREAD_MUTEXES_TIMEOUTS
 
-#ifdef KSDC_SEMAPHORES_SUPPORTED
+#if HAVE_SHARED_SEMAPHORES
 class semaphoreLock : public KSDCLock
 {
 public:
@@ -198,41 +204,37 @@ class semaphoreLock : public KSDCLock (public)
     {
     }
 
-    virtual bool initialize(bool &processSharingSupported)
+    virtual bool initialize()
     {
-        processSharingSupported = false;
-        if (::sysconf(_SC_SEMAPHORES) < 200112L) {
+        if (::sem_init(&m_semaphore, 1, 1) == -1) {
+            ksdcErrOut("sem_init", errno);
             return false;
         }
-
-        // sem_init sets up process-sharing for us.
-        if (sem_init(&m_semaphore, 1, 1) == 0) {
-            processSharingSupported = true;
-        }
-        // If not successful try falling back to thread-shared.
-        else if (sem_init(&m_semaphore, 0, 1) != 0) {
-            return false;
-        }
-
         return true;
     }
 
     virtual bool lock()
     {
-        return sem_wait(&m_semaphore) == 0;
+        if (::sem_wait(&m_semaphore) == -1) {
+            ksdcErrOut("sem_wait", errno);
+            return false;
+        }
+        return true;
     }
 
     virtual void unlock()
     {
-        sem_post(&m_semaphore);
+        if (::sem_post(&m_semaphore) == -1) {
+            ksdcErrOut("sem_post", errno);
+        }
     }
 
 protected:
     sem_t &m_semaphore;
 };
-#endif
+#endif    // HAVE_SHARED_SEMAPHORES
 
-#if defined(KSDC_SEMAPHORES_SUPPORTED) && defined(KSDC_TIMEOUTS_SUPPORTED)
+#if HAVE_SHARED_SEMAPHORES_TIMEOUTS
 class semaphoreTimedLock : public semaphoreLock
 {
 public:
@@ -248,14 +250,205 @@ class semaphoreTimedLock : public semaphoreLock (publi
         // Long timeout, but if we fail to meet this timeout it's probably a cache
         // corruption (and if we take 8 seconds then it should be much much quicker
         // the next time anyways since we'd be paged back in from disk)
-        timeout.tv_sec = 10 + ::time(NULL); // Absolute time, so 10 seconds from now
+        timeout.tv_sec = KSDC_WAIT_TIMEOUT + ::time(NULL); // Absolute time, so count from now
         timeout.tv_nsec = 0;
 
-        return sem_timedwait(&m_semaphore, &timeout) == 0;
+        if (::sem_timedwait(&m_semaphore, &timeout) == -1) {
+            if (errno == ETIMEDOUT) {
+                kWarning(ksdcArea()) << "sem_timedwait timed out";
+            } else {
+                ksdcErrOut("sem_timedwait", errno);
+            }
+            return false;
+        }
     }
 };
+#endif    // HAVE_SHARED_SEMAPHORES_TIMEOUTS
+
+#if KSDC_FILELOCKS_SUPPORTED
+// Implement locking via native file locking mechanisms.
+// Prefer flock() over lockf() because flock() locks do not release when any
+// descriptor for this file (inode) is closed.
+// See "Everything you never wanted to know about file locking"
+// http://apenwarr.ca/log/?m=201012#13 for details.
+class fileLock : public KSDCLock
+{
+public:
+    // Duplicate to make sure position doesn't change
+    fileLock(int fd)
+        : m_fd(::dup(fd)),
+          m_initialized(false)
+    {
+        kDebug(ksdcArea()) << "created on fd" << m_fd;
+    }
+
+    virtual ~fileLock() {
+        kWarning(ksdcArea()) << "destroying";
+        if (m_initialized) {
+            int rc = ::pthread_mutex_destroy(&m_mutex);
+            if (rc != 0) {
+                kError(ksdcArea()) << "pthread_mutex_destroy failed, errno:" << rc;
+            }
+        }
+        if (m_fd != -1 && ::close(m_fd) == -1) {
+            kError(ksdcArea()) << "close failed, errno:" << errno;
+        }
+    }
+
+    // This technically should be done in constructor instead because our data
+    // does not lie in shared memory, but we want to fail gracefully. So we'll
+    // check in lock() below if we're actually initialized.
+    virtual bool initialize()
+    {
+        int rc;
+
+#if HAVE_FLOCK
+        // In case of flock() we obviously should avoid child inheriting any acquired locks.
+        // Probably not a problem for KDE but it's better to be safe than sorry.
+        if (::fcntl(m_fd, F_SETFD, FD_CLOEXEC) == -1) {
+            ksdcErrOut("fcntl", errno);
+            return false;
+        }
+#else
+        // In case of lockf() make sure we lock the entire cache file.
+        if (::lseek(m_fd, 0, SEEK_SET) == -1) {
+            ksdcErrOut("lseek", errno);
+            return false;
+        }
 #endif
 
+        rc = ::pthread_mutex_init(&m_mutex, NULL);
+        if (rc != 0) {
+            ksdcErrOut("pthread_mutex_init", rc);
+            return false;
+        }
+
+        m_initialized = true;
+        return true;
+    }
+
+    virtual bool lock()
+    {
+#if HAVE_PTHREAD_MUTEXES_TIMEOUTS
+        struct timespec timeout;
+#endif
+        int flags, rc;
+
+        if (m_fd == -1) {
+            kWarning(ksdcArea()) << "file descriptor is closed, lock failed";
+            return false;
+        }
+
+        // initialize() is called only after cache creation
+        if (!m_initialized) {
+            if (!initialize()) {
+                kError(ksdcArea()) << "initialization failed, lock failed";
+                return false;
+            }
+        }
+
+        // We use two locks: file lock for process-shared locking and simple
+        // mutex for thread-sharing.
+        //
+        // First acquire smaller lock (thread-level), then try bigger one
+        // (process level). Otherwise the following could happen:
+        //   1. Process 1000, thread 1 (1000/1 later) acquires both locks
+        //   2. Process 2000 tries to acquire file lock and starts waiting.
+        //   3. Process 1000/2 successfully acquires file lock and starts
+        //      waiting on thread lock.
+        //   4a. Process 1000/1 frees file lock, then thread lock: PID 2000
+        //       acquires file lock but process 1000/2 still thinks it acquired
+        //       file lock too. Now both 1000/2 and 2000 acquire thread locks in
+        //       their processes and go async. Kaboom.
+        //   4b. Process 1000/1 frees thread lock, then file lock: 1000/2
+        //       acquires file lock and then 1000/1 frees it, allowing 2000 to
+        //       join the game too. Now both 1000/2 and 2000 will both acquire
+        //       thread locks... you already know what happens next.
+
+#if HAVE_PTHREAD_MUTEXES_TIMEOUTS
+        timeout.tv_sec = KSDC_WAIT_TIMEOUT;
+        timeout.tv_nsec = 0;
+        rc = ::pthread_mutex_timedlock(&m_mutex, &timeout);
+#else
+        rc = ::pthread_mutex_lock(&m_mutex);
+#endif
+        if (rc != 0) {
+            if (rc == EBUSY) {
+                kWarning(ksdcArea()) << "thread lock timed out";
+            } else {
+#if HAVE_PTHREAD_MUTEXES_TIMEOUTS
+                ksdcErrOut("pthread_mutex_timedlock", rc);
+#else
+                ksdcErrOut("pthread_mutex_lock", rc);
+#endif
+            }
+            return false;
+        }
+
+#if HAVE_FLOCK
+        rc = ::flock(m_fd, LOCK_EX);
+#else
+        rc = ::lockf(m_fd, F_LOCK, 0);
+#endif
+        if (rc == -1) {
+            rc = errno;    // minimize possible race window for errno change.
+            if (rc == EBADF) {
+                m_fd = -1;    // do not try to lock it anymore
+            }
+#if HAVE_FLOCK
+            ksdcErrOut("flock(m_fd, LOCK_EX)", rc);
+#else
+            ksdcErrOut("lockf((m_fd, F_LOCK, 0)", rc);
+#endif
+            ::pthread_mutex_unlock(&m_mutex);
+            return false;
+        }
+
+        return true;
+    }
+
+    virtual void unlock()
+    {
+        int rc;
+
+        if (m_fd == -1) {
+            kWarning(ksdcArea()) << "file descriptor is closed, fail to unlock";
+            return;
+        }
+
+        // Proceed with locks in the reverse order relative to lock()
+#ifdef HAVE_FLOCK
+        rc = ::flock(m_fd, LOCK_UN);
+#else
+        rc = ::lockf(m_fd, F_ULOCK, 0);
+#endif
+        if (rc == -1) {
+            rc = errno;    // minimize possible race window for errno change.
+            if (rc == EBADF) {
+                m_fd = -1;    // do not try to lock it anymore
+            }
+#if HAVE_FLOCK
+            ksdcErrOut("flock(m_fd, LOCK_UN)", rc);
+#else
+            ksdcErrOut("lockf((m_fd, F_ULOCK, 0)", rc);
+#endif
+        }
+
+        rc = ::pthread_mutex_unlock(&m_mutex);
+        if (rc != 0) {
+            ksdcErrOut("pthread_mutex_unlock", rc);
+        }
+    }
+
+protected:
+    int m_fd;
+    pthread_mutex_t m_mutex;
+
+private:
+    bool m_initialized;
+};
+#endif    // KSDC_FILELOCKS_SUPPORTED
+
 // This enum controls the type of the locking used for the cache to allow
 // for as much portability as possible. This value will be stored in the
 // cache and used by multiple processes, therefore you should consider this
@@ -263,7 +456,8 @@ class semaphoreTimedLock : public semaphoreLock (publi
 enum SharedLockId {
     LOCKTYPE_INVALID   = 0,
     LOCKTYPE_MUTEX     = 1,  // pthread_mutex
-    LOCKTYPE_SEMAPHORE = 2   // sem_t
+    LOCKTYPE_SEMAPHORE = 2,  // sem_t
+    LOCKTYPE_FILE      = 4,  // pthread_mutex_t + int, not in shared memory
 };
 
 // This type is a union of all possible lock types, with a SharedLockId used
@@ -272,10 +466,10 @@ struct SharedLock
 {
     union
     {
-#if defined(KSDC_THREAD_PROCESS_SHARED_SUPPORTED)
+#if HAVE_SHARED_PTHREAD_MUTEXES
         pthread_mutex_t mutex;
 #endif
-#if defined(KSDC_SEMAPHORES_SUPPORTED)
+#if HAVE_SHARED_SEMAPHORES
         sem_t semaphore;
 #endif
 
@@ -296,103 +490,55 @@ struct SharedLock
  */
 static SharedLockId findBestSharedLock()
 {
-    // We would prefer a process-shared capability that also supports
-    // timeouts. Failing that, process-shared is preferred over timeout
-    // support. Failing that we'll go thread-local
-    bool pthreadsSupported = false;
-    bool semaphoresSupported = false;
-    bool timeoutsSupported = false;
-    bool pthreadsProcessShared = false;
-    bool semaphoresProcessShared = false;
+    // The selection logic is simple:
+    //   1. Prefer locks with timeouts over forever blocking ones.
+    //   2. Prefer pthread mutexes over semaphores because the former are more
+    //      portable and error-prone (errno is not used).
+    //   3. Otherwise, go without locking (and caching).
 
-#ifdef KSDC_TIMEOUTS_SUPPORTED
-    timeoutsSupported = ::sysconf(_SC_TIMEOUTS) >= 200112L;
-#endif
-
-    // Now that we've queried timeouts, try actually creating real locks and
-    // seeing if there's issues with that.
-#ifdef KSDC_THREAD_PROCESS_SHARED_SUPPORTED
-    {
-        pthread_mutex_t tempMutex;
-        QSharedPointer<KSDCLock> tempLock(0);
-        if (timeoutsSupported) {
-#ifdef KSDC_TIMEOUTS_SUPPORTED
-            tempLock = QSharedPointer<KSDCLock>(new pthreadTimedLock(tempMutex));
-#endif
-        }
-        else {
-            tempLock = QSharedPointer<KSDCLock>(new pthreadLock(tempMutex));
-        }
-
-        pthreadsSupported = tempLock->initialize(pthreadsProcessShared);
-    }
-#endif
-
-    // Our first choice is pthread_mutex_t for compatibility.
-    if(timeoutsSupported && pthreadsProcessShared) {
-        return LOCKTYPE_MUTEX;
-    }
-
-#ifdef KSDC_SEMAPHORES_SUPPORTED
-    {
-        sem_t tempSemaphore;
-        QSharedPointer<KSDCLock> tempLock(0);
-        if (timeoutsSupported) {
-            tempLock = QSharedPointer<KSDCLock>(new semaphoreTimedLock(tempSemaphore));
-        }
-        else {
-            tempLock = QSharedPointer<KSDCLock>(new semaphoreLock(tempSemaphore));
-        }
-
-        semaphoresSupported = tempLock->initialize(semaphoresProcessShared);
-    }
-#endif
-
-    if(timeoutsSupported && semaphoresProcessShared) {
-        return LOCKTYPE_SEMAPHORE;
-    }
-    else if(pthreadsProcessShared) {
-        return LOCKTYPE_MUTEX;
-    }
-    else if(semaphoresProcessShared) {
-        return LOCKTYPE_SEMAPHORE;
-    }
-    else if(pthreadsSupported) {
-        return LOCKTYPE_MUTEX;
-    }
-    else if(semaphoresSupported) {
-        return LOCKTYPE_SEMAPHORE;
-    }
-
+#if HAVE_SHARED_PTHREAD_MUTEXES_TIMEOUTS
+    return LOCKTYPE_MUTEX;
+#elif HAVE_SHARED_SEMAPHORES_TIMEOUTS
+    return LOCKTYPE_SEMAPHORE;
+#elif HAVE_SHARED_PTHREAD_MUTEXES
+    return LOCKTYPE_MUTEX
+#elif HAVE_SHARED_SEMAPHORES
+    return LOCKTYPE_SEMAPHORE;
+#elif KSDC_FILELOCKS_SUPPORTED
+    return LOCKTYPE_FILE;
+#else
     // If we get to this point we'll likely fail later but this is the
     // standard behavior that has existed as well, so...
     return static_cast<SharedLockId>(0);
+#endif
 }
 
-static KSDCLock *createLockFromId(SharedLockId id, SharedLock &lock)
+static KSDCLock *createLockFromId(SharedLockId id, SharedLock &lock, int fd)
 {
     switch(id) {
-#ifdef KSDC_THREAD_PROCESS_SHARED_SUPPORTED
+#if HAVE_SHARED_PTHREAD_MUTEXES
     case LOCKTYPE_MUTEX:
-#ifdef KSDC_TIMEOUTS_SUPPORTED
-        if (::sysconf(_SC_TIMEOUTS) >= 200112L) {
-            return new pthreadTimedLock(lock.mutex);
-        }
-#endif
+# if HAVE_SHARED_PTHREAD_MUTEXES_TIMEOUTS
+        return new pthreadTimedLock(lock.mutex);
+# else
         return new pthreadLock(lock.mutex);
-
+# endif
     break;
 #endif
 
-#ifdef KSDC_SEMAPHORES_SUPPORTED
+#if HAVE_SHARED_SEMAPHORES
     case LOCKTYPE_SEMAPHORE:
-#ifdef KSDC_TIMEOUTS_SUPPORTED
-        if (::sysconf(_SC_SEMAPHORES) >= 200112L) {
-            return new semaphoreTimedLock(lock.semaphore);
-        }
-#endif
+# if HAVE_SHARED_SEMAPHORES_TIMEOUTS
+        return new semaphoreTimedLock(lock.semaphore);
+# else
         return new semaphoreLock(lock.semaphore);
+# endif
+    break;
+#endif
 
+#if KSDC_FILELOCKS_SUPPORTED
+    case LOCKTYPE_FILE:
+        return new fileLock(fd);
     break;
 #endif
 
@@ -404,7 +550,7 @@ static KSDCLock *createLockFromId(SharedLockId id, Sha
 
 static bool ensureFileAllocated(int fd, size_t fileSize)
 {
-#ifdef KSDC_POSIX_FALLOCATE_SUPPORTED
+#if HAVE_POSIX_FALLOCATE
     int result;
     while ((result = ::posix_fallocate(fd, 0, fileSize)) == EINTR) {
         ;
@@ -419,7 +565,7 @@ static bool ensureFileAllocated(int fd, size_t fileSiz
     }
 
     return true;
-#else
+#else    // HAVE_POSIX_FALLOCATE
 
 #ifdef __GNUC__
 #warning "This system does not seem to support posix_fallocate, which is needed to ensure KSharedDataCache's underlying files are fully committed to disk to avoid crashes with low disk space."
@@ -434,7 +580,7 @@ static bool ensureFileAllocated(int fd, size_t fileSiz
     // new file and not just mapping an existing cache.
 
     return true;
-#endif
+#endif    // HAVE_POSIX_FALLOCATE
 }
 
 #endif /* KSHAREDDATACACHE_P_H */
