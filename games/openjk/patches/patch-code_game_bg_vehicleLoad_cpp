$OpenBSD$

strlcat etc

Index: code/game/bg_vehicleLoad.cpp
--- code/game/bg_vehicleLoad.cpp.orig
+++ code/game/bg_vehicleLoad.cpp
@@ -230,7 +230,7 @@ static qboolean BG_ParseVehWeaponParm( vehWeaponInfo_t
 		{ //just use 1024 bytes in case we want to write over the string
 #ifdef _JK2MP
 			*(char **)(b+vehWeaponField->ofs) = (char *)BG_Alloc(1024);//(char *)BG_Alloc(strlen(value));
-			strcpy(*(char **)(b+vehWeaponField->ofs), value);
+			strlcpy(*(char **)(b+vehWeaponField->ofs), value, sizeof(*(char **)(b+vehWeaponField->ofs)));
 #else
 			(*(char **)(b+vehWeaponField->ofs)) = G_NewString( value );
 #endif
@@ -750,7 +750,7 @@ void BG_VehicleSetDefaults( vehicleInfo_t *vehicle )
 	{
 		vehicle->name = (char *)BG_Alloc(1024);
 	}
-	strcpy(vehicle->name, "default");
+	strlcpy(vehicle->name, "default", sizeof(vehicle->name));
 #else
 	vehicle->name = G_NewString( "default" );
 #endif
@@ -799,7 +799,7 @@ void BG_VehicleSetDefaults( vehicleInfo_t *vehicle )
 	{
 		vehicle->model = (char *)BG_Alloc(1024);
 	}
-	strcpy(vehicle->model, "models/map_objects/ships/swoop.md3");
+	strlcpy(vehicle->model, "models/map_objects/ships/swoop.md3", sizeof(vehicle->model));
 
 	vehicle->modelIndex = 0;							//set internally, not until this vehicle is spawned into the level
 	vehicle->skin = NULL;								//what skin to use - if make it an NPC's primary model, don't need this?
@@ -915,7 +915,7 @@ static qboolean BG_ParseVehicleParm( vehicleInfo_t *ve
 		{ //just use 128 bytes in case we want to write over the string
 #ifdef _JK2MP
 			*(char **)(b+vehField->ofs) = (char *)BG_Alloc(128);//(char *)BG_Alloc(strlen(value));
-			strcpy(*(char **)(b+vehField->ofs), value);
+			strlcpy(*(char **)(b+vehField->ofs), value, sizeof(*(char **)(b+vehField->ofs)));
 #else
 			(*(char **)(b+vehField->ofs)) = G_NewString( value );
 #endif
@@ -1502,7 +1502,7 @@ void BG_VehWeaponLoadParms( void )
 			// Don't let it end on a } because that should be a stand-alone token.
 			if ( totallen && *(marker-1) == '}' )
 			{
-				strcat( marker, " " );
+				strlcat( marker, " " , sizeof(marker));
 				totallen++;
 				marker++;
 			}
@@ -1510,7 +1510,7 @@ void BG_VehWeaponLoadParms( void )
 			if ( totallen + len >= MAX_VEH_WEAPON_DATA_SIZE ) {
 				Com_Error(ERR_DROP, "Vehicle Weapon extensions (*.vwp) are too large" );
 			}
-			strcat( marker, tempReadBuffer );
+			strlcat( marker, tempReadBuffer , sizeof(marker));
 #ifdef _JK2MP
 			trap_FS_FCloseFile( f );
 #else
@@ -1594,7 +1594,7 @@ void BG_VehicleLoadParms( void )
 			// Don't let it end on a } because that should be a stand-alone token.
 			if ( totallen && *(marker-1) == '}' )
 			{
-				strcat( marker, " " );
+				strlcat( marker, " " , sizeof(marker));
 				totallen++;
 				marker++;
 			}
@@ -1602,7 +1602,7 @@ void BG_VehicleLoadParms( void )
 			if ( totallen + len >= MAX_VEHICLE_DATA_SIZE ) {
 				Com_Error(ERR_DROP, "Vehicle extensions (*.veh) are too large" );
 			}
-			strcat( marker, tempReadBuffer );
+			strlcat( marker, tempReadBuffer , sizeof(marker));
 #ifdef _JK2MP
 			trap_FS_FCloseFile( f );
 #else
@@ -1652,7 +1652,7 @@ void BG_GetVehicleModelName(char *modelname)
 		Com_Error(ERR_DROP, "BG_GetVehicleModelName:  couldn't find vehicle %s", vehName);
 	}
 
-    strcpy(modelname, g_vehicleInfo[vIndex].model);
+    strlcpy(modelname, g_vehicleInfo[vIndex].model, sizeof(modelname));
 }
 
 void BG_GetVehicleSkinName(char *skinname)
@@ -1673,7 +1673,7 @@ void BG_GetVehicleSkinName(char *skinname)
 	}
 	else
 	{
-		strcpy(skinname, g_vehicleInfo[vIndex].skin);
+		strlcpy(skinname, g_vehicleInfo[vIndex].skin, sizeof(skinname));
 	}
 }
 
