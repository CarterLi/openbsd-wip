$OpenBSD$
--- lib/Net/HTTP/Methods.pm.orig	Wed Feb 15 19:42:03 2012
+++ lib/Net/HTTP/Methods.pm	Mon Nov  5 20:26:07 2012
@@ -233,6 +233,7 @@ sub my_read {
 	    return length($_[0]);
 	}
 	else {
+	    die "read timeout" unless $self->can_read;
 	    return $self->sysread($_[0], $len);
 	}
     }
@@ -255,15 +256,10 @@ sub my_readline {
 	    # need to read more data to find a line ending
           READ:
             {
+                die "read timeout" unless $self->can_read;
                 my $n = $self->sysread($_, 1024, length);
                 unless (defined $n) {
                     redo READ if $!{EINTR};
-                    if ($!{EAGAIN}) {
-                        # Hmm, we must be reading from a non-blocking socket
-                        # XXX Should really wait until this socket is readable,...
-                        select(undef, undef, undef, 0.1);  # but this will do for now
-                        redo READ;
-                    }
                     # if we have already accumulated some data let's at least
                     # return that as a line
                     die "$what read failed: $!" unless length;
@@ -284,6 +280,37 @@ sub my_readline {
 }
 
 
+sub can_read {
+    my $self = shift;
+    return 1 unless defined(fileno($self));
+
+    # With no timeout, wait forever.  An explict timeout of 0 can be
+    # used to just check if the socket is readable without waiting.
+    my $timeout = @_ ? shift : (${*$self}{io_socket_timeout} || undef);
+
+    my $fbits = '';
+    vec($fbits, fileno($self), 1) = 1;
+  SELECT:
+    {
+        my $before;
+        $before = time if $timeout;
+        my $nfound = select($fbits, undef, undef, $timeout);
+        if ($nfound < 0) {
+            if ($!{EINTR} || $!{EAGAIN}) {
+                # don't really think EAGAIN can happen here
+                if ($timeout) {
+                    $timeout -= time - $before;
+                    $timeout = 0 if $timeout < 0;
+                }
+                redo SELECT;
+            }
+            die "select failed: $!";
+        }
+        return $nfound > 0;
+    }
+}
+
+
 sub _rbuf {
     my $self = shift;
     if (@_) {
@@ -415,6 +442,7 @@ sub read_entity_body {
 	    my @te = split(/\s*,\s*/, lc($te));
 	    die "Chunked must be last Transfer-Encoding '$te'"
 		unless pop(@te) eq "chunked";
+	    pop(@te) while @te && $te[-1] eq "chunked";  # ignore repeated chunked spec
 
 	    for (@te) {
 		if ($_ eq "deflate" && inflate_ok()) {
@@ -489,6 +517,7 @@ sub read_entity_body {
 		die "Bad chunk-size in HTTP response: $line";
 	    }
 	    $chunked = hex($1);
+	    ${*$self}{'http_chunked'} = $chunked;
 	    if ($chunked == 0) {
 		${*$self}{'http_trailers'} = [$self->_read_header_lines];
 		$$buf_ref = "";
$OpenBSD$
--- lib/Net/HTTP/Methods.pm.orig	Wed Feb 15 19:42:03 2012
+++ lib/Net/HTTP/Methods.pm	Mon Nov  5 20:26:07 2012
@@ -233,6 +233,7 @@ sub my_read {
 	    return length($_[0]);
 	}
 	else {
+	    die "read timeout" unless $self->can_read;
 	    return $self->sysread($_[0], $len);
 	}
     }
@@ -255,15 +256,10 @@ sub my_readline {
 	    # need to read more data to find a line ending
           READ:
             {
+                die "read timeout" unless $self->can_read;
                 my $n = $self->sysread($_, 1024, length);
                 unless (defined $n) {
                     redo READ if $!{EINTR};
-                    if ($!{EAGAIN}) {
-                        # Hmm, we must be reading from a non-blocking socket
-                        # XXX Should really wait until this socket is readable,...
-                        select(undef, undef, undef, 0.1);  # but this will do for now
-                        redo READ;
-                    }
                     # if we have already accumulated some data let's at least
                     # return that as a line
                     die "$what read failed: $!" unless length;
@@ -284,6 +280,37 @@ sub my_readline {
 }
 
 
+sub can_read {
+    my $self = shift;
+    return 1 unless defined(fileno($self));
+
+    # With no timeout, wait forever.  An explict timeout of 0 can be
+    # used to just check if the socket is readable without waiting.
+    my $timeout = @_ ? shift : (${*$self}{io_socket_timeout} || undef);
+
+    my $fbits = '';
+    vec($fbits, fileno($self), 1) = 1;
+  SELECT:
+    {
+        my $before;
+        $before = time if $timeout;
+        my $nfound = select($fbits, undef, undef, $timeout);
+        if ($nfound < 0) {
+            if ($!{EINTR} || $!{EAGAIN}) {
+                # don't really think EAGAIN can happen here
+                if ($timeout) {
+                    $timeout -= time - $before;
+                    $timeout = 0 if $timeout < 0;
+                }
+                redo SELECT;
+            }
+            die "select failed: $!";
+        }
+        return $nfound > 0;
+    }
+}
+
+
 sub _rbuf {
     my $self = shift;
     if (@_) {
@@ -415,6 +442,7 @@ sub read_entity_body {
 	    my @te = split(/\s*,\s*/, lc($te));
 	    die "Chunked must be last Transfer-Encoding '$te'"
 		unless pop(@te) eq "chunked";
+	    pop(@te) while @te && $te[-1] eq "chunked";  # ignore repeated chunked spec
 
 	    for (@te) {
 		if ($_ eq "deflate" && inflate_ok()) {
@@ -489,6 +517,7 @@ sub read_entity_body {
 		die "Bad chunk-size in HTTP response: $line";
 	    }
 	    $chunked = hex($1);
+	    ${*$self}{'http_chunked'} = $chunked;
 	    if ($chunked == 0) {
 		${*$self}{'http_trailers'} = [$self->_read_header_lines];
 		$$buf_ref = "";
$OpenBSD$
--- lib/Net/HTTP/Methods.pm.orig	Wed Feb 15 19:42:03 2012
+++ lib/Net/HTTP/Methods.pm	Mon Nov  5 20:26:07 2012
@@ -233,6 +233,7 @@ sub my_read {
 	    return length($_[0]);
 	}
 	else {
+	    die "read timeout" unless $self->can_read;
 	    return $self->sysread($_[0], $len);
 	}
     }
@@ -255,15 +256,10 @@ sub my_readline {
 	    # need to read more data to find a line ending
           READ:
             {
+                die "read timeout" unless $self->can_read;
                 my $n = $self->sysread($_, 1024, length);
                 unless (defined $n) {
                     redo READ if $!{EINTR};
-                    if ($!{EAGAIN}) {
-                        # Hmm, we must be reading from a non-blocking socket
-                        # XXX Should really wait until this socket is readable,...
-                        select(undef, undef, undef, 0.1);  # but this will do for now
-                        redo READ;
-                    }
                     # if we have already accumulated some data let's at least
                     # return that as a line
                     die "$what read failed: $!" unless length;
@@ -284,6 +280,37 @@ sub my_readline {
 }
 
 
+sub can_read {
+    my $self = shift;
+    return 1 unless defined(fileno($self));
+
+    # With no timeout, wait forever.  An explict timeout of 0 can be
+    # used to just check if the socket is readable without waiting.
+    my $timeout = @_ ? shift : (${*$self}{io_socket_timeout} || undef);
+
+    my $fbits = '';
+    vec($fbits, fileno($self), 1) = 1;
+  SELECT:
+    {
+        my $before;
+        $before = time if $timeout;
+        my $nfound = select($fbits, undef, undef, $timeout);
+        if ($nfound < 0) {
+            if ($!{EINTR} || $!{EAGAIN}) {
+                # don't really think EAGAIN can happen here
+                if ($timeout) {
+                    $timeout -= time - $before;
+                    $timeout = 0 if $timeout < 0;
+                }
+                redo SELECT;
+            }
+            die "select failed: $!";
+        }
+        return $nfound > 0;
+    }
+}
+
+
 sub _rbuf {
     my $self = shift;
     if (@_) {
@@ -415,6 +442,7 @@ sub read_entity_body {
 	    my @te = split(/\s*,\s*/, lc($te));
 	    die "Chunked must be last Transfer-Encoding '$te'"
 		unless pop(@te) eq "chunked";
+	    pop(@te) while @te && $te[-1] eq "chunked";  # ignore repeated chunked spec
 
 	    for (@te) {
 		if ($_ eq "deflate" && inflate_ok()) {
@@ -489,6 +517,7 @@ sub read_entity_body {
 		die "Bad chunk-size in HTTP response: $line";
 	    }
 	    $chunked = hex($1);
+	    ${*$self}{'http_chunked'} = $chunked;
 	    if ($chunked == 0) {
 		${*$self}{'http_trailers'} = [$self->_read_header_lines];
 		$$buf_ref = "";
$OpenBSD$
--- lib/Net/HTTP/Methods.pm.orig	Wed Feb 15 19:42:03 2012
+++ lib/Net/HTTP/Methods.pm	Mon Nov  5 20:26:07 2012
@@ -233,6 +233,7 @@ sub my_read {
 	    return length($_[0]);
 	}
 	else {
+	    die "read timeout" unless $self->can_read;
 	    return $self->sysread($_[0], $len);
 	}
     }
@@ -255,15 +256,10 @@ sub my_readline {
 	    # need to read more data to find a line ending
           READ:
             {
+                die "read timeout" unless $self->can_read;
                 my $n = $self->sysread($_, 1024, length);
                 unless (defined $n) {
                     redo READ if $!{EINTR};
-                    if ($!{EAGAIN}) {
-                        # Hmm, we must be reading from a non-blocking socket
-                        # XXX Should really wait until this socket is readable,...
-                        select(undef, undef, undef, 0.1);  # but this will do for now
-                        redo READ;
-                    }
                     # if we have already accumulated some data let's at least
                     # return that as a line
                     die "$what read failed: $!" unless length;
@@ -284,6 +280,37 @@ sub my_readline {
 }
 
 
+sub can_read {
+    my $self = shift;
+    return 1 unless defined(fileno($self));
+
+    # With no timeout, wait forever.  An explict timeout of 0 can be
+    # used to just check if the socket is readable without waiting.
+    my $timeout = @_ ? shift : (${*$self}{io_socket_timeout} || undef);
+
+    my $fbits = '';
+    vec($fbits, fileno($self), 1) = 1;
+  SELECT:
+    {
+        my $before;
+        $before = time if $timeout;
+        my $nfound = select($fbits, undef, undef, $timeout);
+        if ($nfound < 0) {
+            if ($!{EINTR} || $!{EAGAIN}) {
+                # don't really think EAGAIN can happen here
+                if ($timeout) {
+                    $timeout -= time - $before;
+                    $timeout = 0 if $timeout < 0;
+                }
+                redo SELECT;
+            }
+            die "select failed: $!";
+        }
+        return $nfound > 0;
+    }
+}
+
+
 sub _rbuf {
     my $self = shift;
     if (@_) {
@@ -415,6 +442,7 @@ sub read_entity_body {
 	    my @te = split(/\s*,\s*/, lc($te));
 	    die "Chunked must be last Transfer-Encoding '$te'"
 		unless pop(@te) eq "chunked";
+	    pop(@te) while @te && $te[-1] eq "chunked";  # ignore repeated chunked spec
 
 	    for (@te) {
 		if ($_ eq "deflate" && inflate_ok()) {
@@ -489,6 +517,7 @@ sub read_entity_body {
 		die "Bad chunk-size in HTTP response: $line";
 	    }
 	    $chunked = hex($1);
+	    ${*$self}{'http_chunked'} = $chunked;
 	    if ($chunked == 0) {
 		${*$self}{'http_trailers'} = [$self->_read_header_lines];
 		$$buf_ref = "";
