$OpenBSD$
--- src/libthread/OpenBSD-386-asm.S.orig	Thu Jan 19 20:12:01 2012
+++ src/libthread/OpenBSD-386-asm.S	Thu Jan 19 20:18:41 2012
@@ -1,6 +1,6 @@
 #include "FreeBSD-386-asm.s"
 
-/*
+/*-
  * Copyright (c) 2000 Peter Wemm <peter@FreeBSD.org>
  * All rights reserved.
  *
@@ -28,73 +28,93 @@
 
 #include <sys/syscall.h>
 #include <machine/asm.h>
+#if 0
+__FBSDID("$FreeBSD: /repoman/r/ncvs/src/lib/libc/i386/gen/rfork_thread.S,v 1.5 2003/05/07 17:23:25 jhb Exp $");
+#endif
 
-ENTRY(rfork_thread)
-	pushl   %ebp
-	movl    %esp, %ebp
-	pushl   %esi
+/*
+ * With thanks to John Dyson for the original version of this.
+ */
 
+/* #include "../../../libc/arch/i386/SYS.h" */
+
+/*
+ *                8      12          16         20
+ * __tfork_thread(param, stack_addr, start_fnc, start_arg);
+ *
+ * param:		Arguments to actual system call.
+ * stack_addr:		Top of stack for thread.
+ * start_fnc:		Address of thread function to call in child.
+ * start_arg:		Argument to pass to the thread function in child.
+ */
+
+ENTRY(__tfork_thread)
+	pushl	%ebp
+	movl	%esp, %ebp
+	pushl	%esi
+
 	/*
-	* Push thread info onto the new thread's stack
-	*/
-	movl    12(%ebp), %esi  # get stack addr
+	 * Push thread info onto the new thread's stack
+	 */
+	movl	12(%ebp), %esi	# get stack addr
 
-	subl    $4, %esi
-	movl    20(%ebp), %eax  # get start argument
-	movl    %eax, (%esi)
+	subl	$4, %esi
+	movl	20(%ebp), %eax	# get start argument
+	movl	%eax, (%esi)
 
-	subl    $4, %esi
-	movl    16(%ebp), %eax  # get start thread address
-	movl    %eax, (%esi)
+	subl	$4, %esi
+	movl	16(%ebp), %eax	# get start thread address
+	movl	%eax, (%esi)
 
 	/*
-	* Prepare and execute the thread creation syscall
-	*/
-	pushl   8(%ebp)
-	pushl   $0
-	movl    $SYS_rfork, %eax
-	int     $0x80
-	jb      2f
+	 * Prepare and execute the thread creation syscall
+	 */
+	pushl	8(%ebp)
+	pushl	$0
+	movl	$SYS___tfork, %eax
+	int	$0x80
+	jb 	2f
 
 	/*
-	* Check to see if we are in the parent or child
-	*/
-	cmpl    $0, %edx
-	jnz     1f
-	addl    $8, %esp
-	popl    %esi
-	movl    %ebp, %esp
-	popl    %ebp
+	 * Check to see if we are in the parent or child
+	 */
+	cmpl	$0, %edx
+	jnz	1f
+	addl	$8, %esp
+	popl	%esi
+	movl	%ebp, %esp
+	popl	%ebp
 	ret
 	.p2align 2
 
 	/*
-	* If we are in the child (new thread), then
-	* set-up the call to the internal subroutine.  If it
-	* returns, then call __exit.
-	*/
+	 * If we are in the child (new thread), then
+	 * set-up the call to the internal subroutine.  If it
+	 * returns, then call __exit.
+	 */
 1:
-	movl    %esi,%esp
-	popl    %eax
-	call    *%eax
-	addl    $4, %esp
+	movl	%esi,%esp
+	popl	%eax 
+	call	*%eax
+	addl	$4, %esp
 
 	/*
-	* Exit system call
-	*/
-	pushl   %eax
-	pushl   $0
-	movl    $SYS_exit, %eax
-	int     $0x80
+	 * Exit system call
+	 */
+	pushl	%eax
+	pushl	$0
+	movl	$SYS___threxit, %eax
+	int	$0x80
 
 	/*
-	* Branch here if the thread creation fails:
-	*/
+	 * Branch here if the thread creation fails:
+	 */
 2:
-	addl    $8, %esp
-	popl    %esi
-	movl    %ebp, %esp
-	popl    %ebp
+	addl	$8, %esp
+	popl	%esi
+	movl	%ebp, %esp
+	popl	%ebp
 	PIC_PROLOGUE
-	jmp     PIC_PLT(_C_LABEL(__cerror))
-
+	movl	PIC_GOT(CERROR), %ecx
+	PIC_EPILOGUE
+	jmp	*%ecx
